<!doctype html><html lang=en dir=auto><head><link rel=stylesheet type=text/css href=/css/override.css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevAttackOps: Container CI/CD Pipelines | Ezra Buckingham</title><meta name=keywords content="red-team,infrastructure,docker,containers,devattackops,gitlab"><meta name=description content="Build your containers in CI/CD Pipelines"><meta name=author content="Ezra Buckingham"><link rel=canonical href=https://ezrabuckingham.com/blog/containers-ci_cd/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ezrabuckingham.com/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://ezrabuckingham.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ezrabuckingham.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ezrabuckingham.com/apple-touch-icon.png><link rel=mask-icon href=https://ezrabuckingham.com/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W331QM25YY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W331QM25YY",{anonymize_ip:!1})}</script><meta property="og:title" content="DevAttackOps: Container CI/CD Pipelines"><meta property="og:description" content="Build your containers in CI/CD Pipelines"><meta property="og:type" content="article"><meta property="og:url" content="https://ezrabuckingham.com/blog/containers-ci_cd/"><meta property="og:image" content="https://ezrabuckingham.com/blog/containers-ci_cd/blog-covers/ci-cd_containers.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-29T16:37:55-04:00"><meta property="article:modified_time" content="2022-08-29T16:37:55-04:00"><meta property="og:site_name" content="Ezra Buckingham"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ezrabuckingham.com/blog/containers-ci_cd/blog-covers/ci-cd_containers.png"><meta name=twitter:title content="DevAttackOps: Container CI/CD Pipelines"><meta name=twitter:description content="Build your containers in CI/CD Pipelines"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://ezrabuckingham.com/blog/"},{"@type":"ListItem","position":3,"name":"DevAttackOps: Container CI/CD Pipelines","item":"https://ezrabuckingham.com/blog/containers-ci_cd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DevAttackOps: Container CI/CD Pipelines","name":"DevAttackOps: Container CI\/CD Pipelines","description":"Build your containers in CI/CD Pipelines","keywords":["red-team","infrastructure","docker","containers","devattackops","gitlab"],"articleBody":"TLDR; Building CI/CD pipelines for containers is not as daunting as it seems. For GitLab specifically, I have included a GitLab CI/CD configuration to automatically build and deploy your custom container images in the Artifacts section.\nDisclaimer: If you haven’t read DevAttackOps Part 1, you should start there as we will use the Cobalt Strike container we built in that post in following examples.\nWelcome to part 2 of the DevAttackOps series where I talk all things Red Team infrastructure automation. In DevAttackOps Part 1, I showed how its possible to take a C2 framework and package it up into a container image. In this post, I will talk about how you can expand on that and build out a CI/CD pipeline to automatically build and deploy those images to a container registry where they can be accessed programmatically.\nIf you work in IT in any capacity, you have heard the term “DevOps” or “Continuous Integration and Continuous Deployment” (CI/CD for short). These terms are the bread and butter for any junior engineer to throw on a resume and have absolutely zero clue what they actually mean (kidding, well only kinda). Today, I will walk you through what they mean to me as a Red Teamer and why you should learn how to integrate your team’s operational infrastructure into a CI/CD pipeline as well.\nKey Terms CI/CD: a method to frequently deliver apps to customers by introducing automation into the stages of app development (Source: RedHat) Container Registry: a single place for your team to manage Docker images (Source: Google Cloud) Why Build a CI/CD Pipeline? If you are reading this, you clearly want to learn and don’t want to be that junior engineer who loves putting buzzwords on their resume without actually understanding the concepts and technology behind them (speaking of which I should probably remove BlockChain from mine, but I digress). Let me convince you why you should care. In my mind, the reasons why you should care are the same as in DevAttackOps Part 1: repeatability and ease of use. However, I will add one more here: reduce complexity.\nRepeatability In a CI/CD pipeline, you have a single source of truth for building and deploying all your images. That means that you will never need to “take notes” on what build arguments you need to use to build a container image. Using a single, well-defined pipeline means that your builds will do the exact same thing each run and there is less room for human error.\nEase of Use Using a CI/CD pipeline means you have control over how you build and where you publish to. For containers, that means you can automatically deploy all container images to a registry and use one line of code to pull that image down and run that container. This is powerful as it allows anyone of any skill level to use your container images (as long as they can authenticate to your registry).\nReduce Complexity As a Red Teamer, I already have a lot I have to learn and remember. The last thing I want to remember is how to install a specific software on a server (leave that up to the sysadmins of the world, you all are the real heroes). In using a CI/CD pipeline, I can use my single source of truth for building all my software and “automate away the minutiae” of infrastructure work so I can focus on the value-add activities of my job.\nBuilding the Pipeline As we go through building out this CI/CD pipeline, I want to remind you that this is not the only solution. There are may different ways to skin the cat (sorry I hate that phrase too), but I want to provide a tangible example for you to go try on your own. In doing so, I will walk you through how you build out a CI/CD pipeline using a GitLab repository as the source and GitLab container registry as the container registry (both of which are FREE so you have no excuses to not build this yourself). However, you can just as easily acomplish the same goal using GitHub Actions and a container registry like AWS ECR (notice my theme of abstracting away the “use case” from the platform, this will come up way more often in the future).\nCreating the Repository Before you can go building your pipeline, we need to think through how we want to organize our code. What I found is that the best way to manage all the container definitions is by having one single repository that has a folder for each container. So let’s start with creating the repository.\nmkdir container-ci_cd cd container-ci_cd git init Adding your First Container Definition Inside of this new repository, we can now create a cobaltstrike folder to hold our Cobalt Strike Dockerfile.\nmkdir cobaltstrike touch Dockerfile Using your favorite IDE or text editor, you can now edit that Dockerfile you just created to hold the same Dockerfile definition you use to build Cobalt Strike. And that’s really all you need to do! We will add more containers in a bit.\nCreating a Basic Pipeline Since we are using GitLab to handle the pipeline, to integrate it with the GitLab CI/CD, all we need to do is add a .gitlab-ci.yml file in the root of our repository (as per the GitLab documentation). The .gitlab-ci.yml file is going to be our workhorse: it will hold all the build and deploy commands for our container images.\nWhen you look at some of the examples on the web of how to structure the .gitlab-ci.yml file, it can get confusing, frustrating, and even scary. However, the one thing to remember is that this file is just a fancy way to run shell commands on a computer that GitLab will spin up whenever you commit to your repository. With that, let’s look at a simple example of the base .gitlab-ci.yml file we will use for our repository.\nbuild: image: docker:19.03.12 stage: build services: - docker:19.03.12-dind before_script: - echo \"Before\" script: - echo \"During\" In this configuration, we are telling GitLab exactly how to run the “build” stage of our pipeline (which is the default stage, you can define other stages too). Within that “build” stage, we are telling GitLab to use the docker:19.03.12 base container image (yes container-ception, we are using a container to build our containers). You will also see that we are using a “service” called docker:19.03.12-dind which now tells GitLab that we want to use the Docker-in-Docker image to execute the container-building commands. The way I think of the services definition is as the “tools” we need to successfully run our commands. On a traditional server, in order for us to build containers, we would need to install Docker onto that system. However, with GitLab’s pipeline, we can just use another container (with all required tools we need already installed on it) to run each command. If we then commit that file up to GitLab, we see that the job will pull back that container image and run our commands.\nI realize that may have lost you since you may still need some more clarification on service definitions, so if you want to check out GitLab’s documentation to fully understand their concept of “services”, they do a great job explaining the technical details.\nUnderstanding the Container Registry Sweet so now we are using GitLab’s CI/CD to execute commands whenever we make changes to the repository. Now we want to make it do something useful, like build our Cobalt Strike container. Since we already know the command to build the container, we can use that as the starting point. However, since we are going to be deploying the container image up to GitLab’s container registry, we need to understand how the registry works. In looking at the GitLab Container Registry documentation, it seems like a standard registry. Only caveat here is that in order to use the registry, we need to use a “personal access token” to sign into the registry before we can interact with it. Before trying to use all these new tools together its important to understand each tool, one at a time.\nTo start using the registry, we need to generate a personal access token. You can do this by going to your user preferences, selecting “Access Tokens” and generating a new token with the scopes write_registry and read_registry.\nOnce you hit create, you should get a token that starts with glpat- of which will now allow you to login to the GitLab registry using the docker CLI.\ndocker login -u ezra-buckingham -p glpat-\u003c...redacted...\u003e registry.gitlab.com Now, we can use that Cobalt Strike Dockerfile we created in the cobaltstrike folder earlier, build it with a tag that points to our new repository called container-ci_cd, and push it up to that repository’s registry (note that ezragit refers to my gitlab organization and container-ci_cd refers to the repository that will be my registry).\ndocker build -t registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike docker push registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest After running those commands, we can see the Cobalt Strike container in our GitLab registry.\nNow to use that container image, any user that has access to that repository can create their own “personal access token” with the registry_read scope and can use the same docker login CLI command to login to registry.gitlab.com and then pull down the container image.\ndocker run registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest Using the Pipeline to Build and Push the Image We now have an understanding of the registry and a basic implementation of the CI/CD pipeline. Now, let’s combine the two. If we take our .gitlab-ci.yml file and copy the commands we just ran into it, everything would work right? Well not exactly… Since the Cobalt Strike container takes in a build-arg, we need to somehow pass that into the CI/CD job. This is where GitLab CI/CD variables come into play. Inside the CI/CD settings of your repository, you can store secrets like the COBALTSTRIKE_LICENSE and pull them into the job.\nHowever, to pull that secret into the job, you must explicitly put that variable into the variables block so that it can be passed into the build commands.\nbuild: image: docker:19.03.12 stage: build services: - docker:19.03.12-dind variables: COBALTSTRIKE_LICENSE: $COBALTSTRIKE_LICENSE script: - docker build -t registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike - docker push registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest Now that we have this, we can commit and push these changes to try out our fancy new build command. But just this isn’t enough, if we push this and see the results, we get an access forbidden when we try to push the image.\nThis is because we need to authenticate to the registry. What’s cool is that we don’t need to generate any credentials, we can use the secrets embedded in the runner to dynamically authenticate to the registry (depending on what user made the change). We can do this using the GitLab default secrets of CI_REGISTRY_USER and CI_REGISTRY_PASSWORD in a docker login command. However, while we are at it, we should also remove some of the hardcoded values too. We can also leverage the CI_REGISTRY to dynamically point to the registry and even create a new variable with the full path to our registry and then reference that in the docker build and push.\nbuild: image: docker:19.03.12 stage: build services: - docker:19.03.12-dind variables: CI_REGISTRY_PATH: $CI_REGISTRY/ezragit/container-ci_cd COBALTSTRIKE_LICENSE: $COBALTSTRIKE_LICENSE before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike - docker push $CI_REGISTRY_PATH/cobaltstrike:latest And when we push these changes, we can see the job completes successfully and automatically builds and deploys our image to our private registry!\nExpanding the Capabilities Now that we have a way to automate this, what if we wanted to add another image to our registry? It’s easy! Let’s build Sliver into our registry. First, we need a new folder for sliver so we can hold our Dockerfile.\nmkdir sliver touch Dockerfile We can (using skills learned in Part 1) build out that Dockerfile to build our Sliver container image.\nFROM debian:stable-slim RUN apt-get update \\ \u0026\u0026 apt-get -y install git wget zip tar file mingw-w64 WORKDIR /opt/sliver RUN wget https://github.com/BishopFox/sliver/releases/download/v1.5.16/sliver-server_linux \\ \u0026\u0026 mv sliver-server_linux sliver-server \\ \u0026\u0026 chmod +x ./sliver-server WORKDIR /opt/sliver EXPOSE 3333 443 80 53/udp ENTRYPOINT [ \"./sliver-server\" ] Then we can add the commands needed to build and push the image directly into our .gitlab-ci.yml file.\nbuild: image: docker:19.03.12 stage: build services: - docker:19.03.12-dind variables: CI_REGISTRY_PATH: $CI_REGISTRY/ezragit/container-ci_cd COBALTSTRIKE_LICENSE: $COBALTSTRIKE_LICENSE before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY script: - docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike - docker push $CI_REGISTRY_PATH/cobaltstrike:latest - docker build -t $CI_REGISTRY_PATH/sliver:latest ./sliver - docker push $CI_REGISTRY_PATH/sliver:latest And yes, it is that easy to build your own CI/CD pipeline to build and deploy container images to a private container registry.\nThe Problems with the Solution We have an awesome start to what is becoming a badass little CI/CD pipeline, but we can do better. There are 2 big problems with what we have come up with: failure tracing and speed (there are more, but topic for another time as it gets deeper into the weeds).\nFailure Tracing In our current solution, if any of the builds or pushes fail, the rest of the pipeline fails. This makes it difficult to track down which container image failed to build and what that failure was.\nSpeed Since all of our commands run in sequence, each build needs to wait until the previous one finishes to start building.\nImproving the Solution We can alleviate both of those problems by splitting out each container build into their own build step, but tie them both into the parent “build” step. We can do this, by defining the parent “build” step inside of the stages list and then use the stage key in each container build to be set to “build”. Since some of that results in a duplication of code (which if you ask me, one of the world’s biggest problems is code duplication), we can use anchors and aliases. If you are unfamiliar with anchors and aliases in YAML, you should learn more about them in this blog post. For our CI/CD configuration, we can create an anchor for a “global” configuration and then reference that anchor as an alias in each build.\nimage: docker:19.03.12 stages: - build # Global Job Config for all container builds (include build arg variables here) .job_configuration_template: \u0026job_configuration stage: build services: - docker:19.03.12-dind variables: CI_REGISTRY_PATH: $CI_REGISTRY/ezragit/container-ci_cd COBALTSTRIKE_LICENSE: $COBALTSTRIKE_LICENSE before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Actual Builds build_cobaltstrike: \u003c\u003c: *job_configuration script: - docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike - docker push $CI_REGISTRY_PATH/cobaltstrike:latest build_sliver: \u003c\u003c: *job_configuration script: - docker build -t $CI_REGISTRY_PATH/sliver:latest ./sliver - docker push $CI_REGISTRY_PATH/sliver:latest With this new and improved CI/CD configuration, when we push to this repository, we will see logically each container build split out into it’s own “job”. This allows us to see who the “trouble child” is if the pipeline fails. Not to mention, now all the containers can be built in parallel (which since we are on the free tier of GitLab, this means we can keep tinkering with CI/CD without paying for the next tier).\nAnd that’s it! You now have your own CI/CD pipeline for your container images. Now that we have a centralized place for all our containers, we can deploy them wherever we would like… I wonder how we might do that in an easy way… stay tuned.\nArtifacts Here is the .gitlab-ci.yml file I use to build all my containers (to add more, I just copy and past the build config and change a few of the values).\nimage: docker:19.03.12 stages: - build # Global Job Config for all container builds (include build arg variables here) .job_configuration_template: \u0026job_configuration stage: build services: - docker:19.03.12-dind variables: CI_REGISTRY_PATH: $CI_REGISTRY/ezragit/container-ci_cd COBALTSTRIKE_LICENSE: $COBALTSTRIKE_LICENSE before_script: - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Actual Builds build_cobaltstrike: \u003c\u003c: *job_configuration script: - docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike - docker push $CI_REGISTRY_PATH/cobaltstrike:latest build_sliver: \u003c\u003c: *job_configuration script: - docker build -t $CI_REGISTRY_PATH/sliver:latest ./sliver - docker push $CI_REGISTRY_PATH/sliver:latest ","wordCount":"2676","inLanguage":"en","image":"https://ezrabuckingham.com/blog/containers-ci_cd/blog-covers/ci-cd_containers.png","datePublished":"2022-08-29T16:37:55-04:00","dateModified":"2022-08-29T16:37:55-04:00","author":{"@type":"Person","name":"Ezra Buckingham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ezrabuckingham.com/blog/containers-ci_cd/"},"publisher":{"@type":"Organization","name":"Ezra Buckingham","logo":{"@type":"ImageObject","url":"https://ezrabuckingham.com/favicon.png"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ezrabuckingham.com accesskey=h title="Ezra Buckingham (Alt + H)"><img src=https://ezrabuckingham.com/EzraBuckingham.png alt aria-label=logo height=35>Ezra Buckingham</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ezrabuckingham.com/blog/ title="Blog Posts"><span>blog</span></a></li><li><a href=https://ezrabuckingham.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://ezrabuckingham.com/about-me/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>DevAttackOps: Container CI/CD Pipelines</h1><div class=post-description>Build your containers in CI/CD Pipelines</div><div class=post-meta><span title='2022-08-29 16:37:55 -0400 -0400'>August 29, 2022</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2676 words&nbsp;·&nbsp;Ezra Buckingham&nbsp;|&nbsp;<a href=https://github.com/ezra-buckingham/ezra-buckingham.github.io/blob/main/content/blog/containers-ci_cd.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://ezrabuckingham.com/blog-covers/ci-cd_containers.png alt=CI/CD></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#key-terms aria-label="Key Terms">Key Terms</a></li><li><a href=#why-build-a-cicd-pipeline aria-label="Why Build a CI/CD Pipeline?">Why Build a CI/CD Pipeline?</a><ul><li><a href=#repeatability aria-label=Repeatability>Repeatability</a></li><li><a href=#ease-of-use aria-label="Ease of Use">Ease of Use</a></li><li><a href=#reduce-complexity aria-label="Reduce Complexity">Reduce Complexity</a></li></ul></li><li><a href=#building-the-pipeline aria-label="Building the Pipeline">Building the Pipeline</a><ul><li><a href=#creating-the-repository aria-label="Creating the Repository">Creating the Repository</a></li><li><a href=#adding-your-first-container-definition aria-label="Adding your First Container Definition">Adding your First Container Definition</a></li><li><a href=#creating-a-basic-pipeline aria-label="Creating a Basic Pipeline">Creating a Basic Pipeline</a></li><li><a href=#understanding-the-container-registry aria-label="Understanding the Container Registry">Understanding the Container Registry</a></li><li><a href=#using-the-pipeline-to-build-and-push-the-image aria-label="Using the Pipeline to Build and Push the Image">Using the Pipeline to Build and Push the Image</a></li></ul></li><li><a href=#expanding-the-capabilities aria-label="Expanding the Capabilities">Expanding the Capabilities</a><ul><li><a href=#the-problems-with-the-solution aria-label="The Problems with the Solution">The Problems with the Solution</a><ul><li><a href=#failure-tracing aria-label="Failure Tracing">Failure Tracing</a></li><li><a href=#speed aria-label=Speed>Speed</a></li></ul></li><li><a href=#improving-the-solution aria-label="Improving the Solution">Improving the Solution</a></li></ul></li><li><a href=#artifacts aria-label=Artifacts>Artifacts</a></li></ul></div></details></div><div class=post-content><p><strong>TLDR;</strong> Building CI/CD pipelines for containers is not as daunting as it seems. For GitLab specifically, I have included a GitLab CI/CD configuration to automatically build and deploy your custom container images in the <a href=#artifacts>Artifacts</a> section.</p><p><strong>Disclaimer:</strong> If you haven&rsquo;t read <a href=../containerizing-red-team-infra>DevAttackOps Part 1</a>, you should start there as we will use the Cobalt Strike container we built in that post in following examples.</p><p>Welcome to part 2 of the DevAttackOps series where I talk all things Red Team infrastructure automation. In <a href=../containerizing-red-team-infra>DevAttackOps Part 1</a>, I showed how its possible to take a C2 framework and package it up into a container image. In this post, I will talk about how you can expand on that and build out a CI/CD pipeline to automatically build and deploy those images to a container registry where they can be accessed programmatically.</p><p>If you work in IT in any capacity, you have heard the term &ldquo;DevOps&rdquo; or &ldquo;Continuous Integration and Continuous Deployment&rdquo; (CI/CD for short). These terms are the bread and butter for any junior engineer to throw on a resume and have absolutely zero clue what they actually mean (kidding, well only kinda). Today, I will walk you through what they mean to me as a Red Teamer and why you should learn how to integrate your team&rsquo;s operational infrastructure into a CI/CD pipeline as well.</p><h1 id=key-terms>Key Terms<a hidden class=anchor aria-hidden=true href=#key-terms>#</a></h1><ul><li>CI/CD: a method to frequently deliver apps to customers by introducing automation into the stages of app development (Source: <a href=https://www.redhat.com/en/topics/devops/what-is-ci-cd>RedHat</a>)</li><li>Container Registry: a single place for your team to manage Docker images (Source: <a href=https://cloud.google.com/container-registry>Google Cloud</a>)</li></ul><h1 id=why-build-a-cicd-pipeline>Why Build a CI/CD Pipeline?<a hidden class=anchor aria-hidden=true href=#why-build-a-cicd-pipeline>#</a></h1><p>If you are reading this, you clearly want to learn and don&rsquo;t want to be that junior engineer who loves putting buzzwords on their resume without actually understanding the concepts and technology behind them (speaking of which I should probably remove BlockChain from mine, but I digress). Let me convince you <em>why</em> you should care. In my mind, the reasons why you should care are the same as in <a href=../containerizing-red-team-infra>DevAttackOps Part 1</a>: repeatability and ease of use. However, I will add one more here: reduce complexity.</p><h2 id=repeatability>Repeatability<a hidden class=anchor aria-hidden=true href=#repeatability>#</a></h2><p>In a CI/CD pipeline, you have a single source of truth for building and deploying all your images. That means that you will never need to &ldquo;take notes&rdquo; on what build arguments you need to use to build a container image. Using a single, well-defined pipeline means that your builds will do the exact same thing each run and there is less room for human error.</p><h2 id=ease-of-use>Ease of Use<a hidden class=anchor aria-hidden=true href=#ease-of-use>#</a></h2><p>Using a CI/CD pipeline means you have control over <em>how you build</em> and <em>where you publish to</em>. For containers, that means you can automatically deploy all container images to a registry and use <em>one line of code</em> to pull that image down and run that container. This is powerful as it allows anyone of any skill level to use your container images (as long as they can authenticate to your registry).</p><h2 id=reduce-complexity>Reduce Complexity<a hidden class=anchor aria-hidden=true href=#reduce-complexity>#</a></h2><p>As a Red Teamer, I already have a lot I have to learn and remember. The last thing I want to remember is how to install a specific software on a server (leave that up to the sysadmins of the world, you all are the real heroes). In using a CI/CD pipeline, I can use my single source of truth for building all my software and &ldquo;automate away the minutiae&rdquo; of infrastructure work so I can focus on the value-add activities of my job.</p><h1 id=building-the-pipeline>Building the Pipeline<a hidden class=anchor aria-hidden=true href=#building-the-pipeline>#</a></h1><p>As we go through building out this CI/CD pipeline, I want to remind you that <em>this is not the only solution</em>. There are may different ways to skin the cat (sorry I hate that phrase too), but I want to provide a tangible example for you to go try on your own. In doing so, I will walk you through how you build out a CI/CD pipeline using a GitLab repository as the source and GitLab container registry as the container registry (both of which are <strong>FREE</strong> so you have no excuses to not build this yourself). However, you can just as easily acomplish the same goal using GitHub Actions and a container registry like AWS ECR (notice my theme of abstracting away the &ldquo;use case&rdquo; from the platform, this will come up way more often in the future).</p><h2 id=creating-the-repository>Creating the Repository<a hidden class=anchor aria-hidden=true href=#creating-the-repository>#</a></h2><p>Before you can go building your pipeline, we need to think through how we want to organize our code. What I found is that the best way to manage all the container definitions is by having one single repository that has a folder for each container. So let&rsquo;s start with creating the repository.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir container-ci_cd
</span></span><span class=line><span class=cl><span class=nb>cd</span> container-ci_cd
</span></span><span class=line><span class=cl>git init
</span></span></code></pre></div><h2 id=adding-your-first-container-definition>Adding your First Container Definition<a hidden class=anchor aria-hidden=true href=#adding-your-first-container-definition>#</a></h2><p>Inside of this new repository, we can now create a <code>cobaltstrike</code> folder to hold our Cobalt Strike <code>Dockerfile</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir cobaltstrike
</span></span><span class=line><span class=cl>touch Dockerfile
</span></span></code></pre></div><p>Using your favorite IDE or text editor, you can now edit that <code>Dockerfile</code> you just created to hold the same <code>Dockerfile</code> definition you use to build Cobalt Strike. And that&rsquo;s really all you need to do! We will add more containers in a bit.</p><h2 id=creating-a-basic-pipeline>Creating a Basic Pipeline<a hidden class=anchor aria-hidden=true href=#creating-a-basic-pipeline>#</a></h2><p>Since we are using GitLab to handle the pipeline, to integrate it with the GitLab CI/CD, all we need to do is add a <code>.gitlab-ci.yml</code> file in the root of our repository (as per the <a href=https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html>GitLab documentation</a>). The <code>.gitlab-ci.yml</code> file is going to be our workhorse: it will hold all the build and deploy commands for our container images.</p><p>When you look at some of the examples on the web of how to structure the <code>.gitlab-ci.yml</code> file, it can get confusing, frustrating, and even scary. However, the one thing to remember is that this file is just a fancy way to run shell commands on a computer that GitLab will spin up whenever you commit to your repository. With that, let&rsquo;s look at a simple example of the base <code>.gitlab-ci.yml</code> file we will use for our repository.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>docker:19.03.12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>stage</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker:19.03.12-dind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>before_script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>echo &#34;Before&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>echo &#34;During&#34;</span><span class=w>
</span></span></span></code></pre></div><p>In this configuration, we are telling GitLab exactly how to run the &ldquo;build&rdquo; stage of our pipeline (which is the default stage, you can define other stages too). Within that &ldquo;build&rdquo; stage, we are telling GitLab to use the <code>docker:19.03.12</code> base container image (yes container-ception, we are using a container to build our containers). You will also see that we are using a &ldquo;service&rdquo; called <code>docker:19.03.12-dind</code> which now tells GitLab that we want to use the Docker-in-Docker image to execute the container-building commands. The way I think of the <code>services</code> definition is as the &ldquo;tools&rdquo; we need to successfully run our commands. On a traditional server, in order for us to build containers, we would need to install Docker onto that system. However, with GitLab&rsquo;s pipeline, we can just use another container (with all required tools we need already installed on it) to run each command. If we then commit that file up to GitLab, we see that the job will pull back that container image and run our commands.</p><figure class=align-center><img loading=lazy src=../../blog-images/test-cicd-build.png#center></figure><blockquote><p>I realize that may have lost you since you may still need some more clarification on <code>service</code> definitions, so if you want to check out <a href=https://docs.gitlab.com/ee/ci/services/>GitLab&rsquo;s documentation</a> to fully understand their concept of &ldquo;services&rdquo;, they do a great job explaining the technical details.</p></blockquote><h2 id=understanding-the-container-registry>Understanding the Container Registry<a hidden class=anchor aria-hidden=true href=#understanding-the-container-registry>#</a></h2><p>Sweet so now we are using GitLab&rsquo;s CI/CD to execute commands whenever we make changes to the repository. Now we want to make it do something useful, like build our Cobalt Strike container. Since we already know the command to build the container, we can use that as the starting point. However, since we are going to be deploying the container image up to GitLab&rsquo;s container registry, we need to understand how the registry works. In looking at the <a href=https://docs.gitlab.com/ee/user/packages/container_registry/>GitLab Container Registry documentation</a>, it seems like a standard registry. Only caveat here is that in order to use the registry, we need to use a &ldquo;personal access token&rdquo; to sign into the registry before we can interact with it. Before trying to use all these new tools <em>together</em> its important to understand each tool, one at a time.</p><p>To start using the registry, we need to generate a personal access token. You can do this by going to your user preferences, selecting &ldquo;Access Tokens&rdquo; and generating a new token with the scopes <code>write_registry</code> and <code>read_registry</code>.</p><figure class=align-center><img loading=lazy src=../../blog-images/generate-pat-gitlab.png#center></figure><p>Once you hit create, you should get a token that starts with <code>glpat-</code> of which will now allow you to login to the GitLab registry using the docker CLI.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker login -u ezra-buckingham -p glpat-&lt;...redacted...&gt; registry.gitlab.com
</span></span></code></pre></div><p>Now, we can use that Cobalt Strike Dockerfile we created in the <code>cobaltstrike</code> folder earlier, build it with a tag that points to our new repository called <code>container-ci_cd</code>, and push it up to that repository&rsquo;s registry (note that <code>ezragit</code> refers to my gitlab organization and <code>container-ci_cd</code> refers to the repository that will be my registry).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest --build-arg <span class=nv>COBALTSTRIKE_LICENSE</span><span class=o>=</span><span class=nv>$COBALTSTRIKE_LICENSE</span> ./cobaltstrike
</span></span><span class=line><span class=cl>docker push registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest
</span></span></code></pre></div><p>After running those commands, we can see the Cobalt Strike container in our GitLab registry.</p><figure class=align-center><img loading=lazy src=../../blog-images/container-in-registry.png#center></figure><p>Now to use that container image, any user that has access to that repository can create their own &ldquo;personal access token&rdquo; with the <code>registry_read</code> scope and can use the same docker login CLI command to login to <code>registry.gitlab.com</code> and then pull down the container image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest
</span></span></code></pre></div><h2 id=using-the-pipeline-to-build-and-push-the-image>Using the Pipeline to Build and Push the Image<a hidden class=anchor aria-hidden=true href=#using-the-pipeline-to-build-and-push-the-image>#</a></h2><p>We now have an understanding of the registry and a basic implementation of the CI/CD pipeline. Now, let&rsquo;s combine the two. If we take our <code>.gitlab-ci.yml</code> file and copy the commands we just ran into it, everything would work right? Well not exactly&mldr; Since the Cobalt Strike container takes in a <code>build-arg</code>, we need to somehow pass that into the CI/CD job. This is where GitLab CI/CD variables come into play. Inside the CI/CD settings of your repository, you can store secrets like the <code>COBALTSTRIKE_LICENSE</code> and pull them into the job.</p><figure class=align-center><img loading=lazy src=../../blog-images/add-cicd-variable.png#center></figure><p>However, to pull that secret into the job, you must explicitly put that variable into the <code>variables</code> block so that it can be passed into the build commands.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>docker:19.03.12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>stage</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker:19.03.12-dind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>variables</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>COBALTSTRIKE_LICENSE</span><span class=p>:</span><span class=w> </span><span class=l>$COBALTSTRIKE_LICENSE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest</span><span class=w>
</span></span></span></code></pre></div><p>Now that we have this, we can commit and push these changes to try out our fancy new build command. But just this isn&rsquo;t enough, if we push this and see the results, we get an access forbidden when we try to push the image.</p><figure class=align-center><img loading=lazy src=../../blog-images/cicd-failed-push.png#center></figure><p>This is because we need to authenticate to the registry. What&rsquo;s cool is that we don&rsquo;t need to generate any credentials, we can use the <code>secrets</code> embedded in the runner to dynamically authenticate to the registry (depending on what user made the change). We can do this using the GitLab default secrets of <code>CI_REGISTRY_USER</code> and <code>CI_REGISTRY_PASSWORD</code> in a docker login command. However, while we are at it, we should also remove some of the hardcoded values too. We can also leverage the <code>CI_REGISTRY</code> to dynamically point to the registry and even create a new variable with the full path to our registry and then reference that in the docker build and push.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>docker:19.03.12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>stage</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker:19.03.12-dind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>variables</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CI_REGISTRY_PATH</span><span class=p>:</span><span class=w> </span><span class=l>$CI_REGISTRY/ezragit/container-ci_cd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>COBALTSTRIKE_LICENSE</span><span class=p>:</span><span class=w> </span><span class=l>$COBALTSTRIKE_LICENSE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>before_script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/cobaltstrike:latest</span><span class=w>
</span></span></span></code></pre></div><p>And when we push these changes, we can see the job completes successfully and automatically builds and deploys our image to our private registry!</p><figure class=align-center><img loading=lazy src=../../blog-images/test-cicd-container-build.png#center></figure><h1 id=expanding-the-capabilities>Expanding the Capabilities<a hidden class=anchor aria-hidden=true href=#expanding-the-capabilities>#</a></h1><p>Now that we have a way to automate this, what if we wanted to add another image to our registry? It&rsquo;s easy! Let&rsquo;s build Sliver into our registry. First, we need a new folder for sliver so we can hold our <code>Dockerfile</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir sliver
</span></span><span class=line><span class=cl>touch Dockerfile
</span></span></code></pre></div><p>We can (using skills learned in Part 1) build out that <code>Dockerfile</code> to build our Sliver container image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Dockerfile data-lang=Dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:stable-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> apt-get -y install git wget zip tar file mingw-w64<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /opt/sliver</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> wget https://github.com/BishopFox/sliver/releases/download/v1.5.16/sliver-server_linux <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> mv sliver-server_linux sliver-server <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> chmod +x ./sliver-server<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /opt/sliver</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 3333 443 80 53/udp</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span> <span class=s2>&#34;./sliver-server&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>Then we can add the commands needed to build and push the image directly into our <code>.gitlab-ci.yml</code> file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>docker:19.03.12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>stage</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker:19.03.12-dind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>variables</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CI_REGISTRY_PATH</span><span class=p>:</span><span class=w> </span><span class=l>$CI_REGISTRY/ezragit/container-ci_cd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>COBALTSTRIKE_LICENSE</span><span class=p>:</span><span class=w> </span><span class=l>$COBALTSTRIKE_LICENSE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>before_script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/cobaltstrike:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/sliver:latest ./sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/sliver:latest</span><span class=w>
</span></span></span></code></pre></div><p>And yes, it is that easy to build your own CI/CD pipeline to build and deploy container images to a private container registry.</p><h2 id=the-problems-with-the-solution>The Problems with the Solution<a hidden class=anchor aria-hidden=true href=#the-problems-with-the-solution>#</a></h2><p>We have an awesome start to what is becoming a badass little CI/CD pipeline, but we can do better. There are 2 big problems with what we have come up with: failure tracing and speed (there are more, but topic for another time as it gets deeper into the weeds).</p><h3 id=failure-tracing>Failure Tracing<a hidden class=anchor aria-hidden=true href=#failure-tracing>#</a></h3><p>In our current solution, if any of the builds or pushes fail, the rest of the pipeline fails. This makes it difficult to track down which container image failed to build and what that failure was.</p><h3 id=speed>Speed<a hidden class=anchor aria-hidden=true href=#speed>#</a></h3><p>Since all of our commands run in sequence, each build needs to wait until the previous one finishes to start building.</p><h2 id=improving-the-solution>Improving the Solution<a hidden class=anchor aria-hidden=true href=#improving-the-solution>#</a></h2><p>We can alleviate both of those problems by splitting out each container build into their own build step, but tie them both into the parent &ldquo;build&rdquo; step. We can do this, by defining the parent &ldquo;build&rdquo; step inside of the <code>stages</code> list and then use the <code>stage</code> key in each container build to be set to &ldquo;build&rdquo;. Since some of that results in a duplication of code (which if you ask me, one of the world&rsquo;s biggest problems is code duplication), we can use anchors and aliases. If you are unfamiliar with anchors and aliases in YAML, you should learn more about them in this <a href=https://medium.com/@kinghuang/docker-compose-anchors-aliases-extensions-a1e4105d70bd>blog post</a>. For our CI/CD configuration, we can create an anchor for a &ldquo;global&rdquo; configuration and then reference that anchor as an alias in each build.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>docker:19.03.12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>stages</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>build </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Global Job Config for all container builds (include build arg variables here)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>.job_configuration_template</span><span class=p>:</span><span class=w> </span><span class=cp>&amp;job_configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>stage</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker:19.03.12-dind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>variables</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CI_REGISTRY_PATH</span><span class=p>:</span><span class=w> </span><span class=l>$CI_REGISTRY/ezragit/container-ci_cd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>COBALTSTRIKE_LICENSE</span><span class=p>:</span><span class=w> </span><span class=l>$COBALTSTRIKE_LICENSE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>before_script</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>   </span>- <span class=l>docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Actual Builds</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>build_cobaltstrike</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>&lt;&lt;</span><span class=p>:</span><span class=w> </span><span class=cp>*job_configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/cobaltstrike:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>build_sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>&lt;&lt;</span><span class=p>:</span><span class=w> </span><span class=cp>*job_configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/sliver:latest ./sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/sliver:latest</span><span class=w>
</span></span></span></code></pre></div><p>With this new and improved CI/CD configuration, when we push to this repository, we will see logically each container build split out into it&rsquo;s own &ldquo;job&rdquo;. This allows us to see who the &ldquo;trouble child&rdquo; is if the pipeline fails. Not to mention, now all the containers can be built in parallel (which since we are on the free tier of GitLab, this means we can keep tinkering with CI/CD without paying for the next tier).</p><figure class=align-center><img loading=lazy src=../../blog-images/cicd-parallel-builds.png#center></figure><p>And that&rsquo;s it! You now have your own CI/CD pipeline for your container images. Now that we have a centralized place for all our containers, we can deploy them wherever we would like&mldr; I wonder how we might do that in an easy way&mldr; stay tuned.</p><h1 id=artifacts>Artifacts<a hidden class=anchor aria-hidden=true href=#artifacts>#</a></h1><p>Here is the <code>.gitlab-ci.yml</code> file I use to build all my containers (to add more, I just copy and past the build config and change a few of the values).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>docker:19.03.12</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>stages</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>build </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Global Job Config for all container builds (include build arg variables here)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>.job_configuration_template</span><span class=p>:</span><span class=w> </span><span class=cp>&amp;job_configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>stage</span><span class=p>:</span><span class=w> </span><span class=l>build</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker:19.03.12-dind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>variables</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>CI_REGISTRY_PATH</span><span class=p>:</span><span class=w> </span><span class=l>$CI_REGISTRY/ezragit/container-ci_cd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>COBALTSTRIKE_LICENSE</span><span class=p>:</span><span class=w> </span><span class=l>$COBALTSTRIKE_LICENSE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>before_script</span><span class=p>:</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>   </span>- <span class=l>docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c># Actual Builds</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>build_cobaltstrike</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>&lt;&lt;</span><span class=p>:</span><span class=w> </span><span class=cp>*job_configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/cobaltstrike:latest --build-arg COBALTSTRIKE_LICENSE=$COBALTSTRIKE_LICENSE ./cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/cobaltstrike:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>build_sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>&lt;&lt;</span><span class=p>:</span><span class=w> </span><span class=cp>*job_configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>script</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker build -t $CI_REGISTRY_PATH/sliver:latest ./sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>docker push $CI_REGISTRY_PATH/sliver:latest</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ezrabuckingham.com/tags/red-team/>red-team</a></li><li><a href=https://ezrabuckingham.com/tags/infrastructure/>infrastructure</a></li><li><a href=https://ezrabuckingham.com/tags/docker/>docker</a></li><li><a href=https://ezrabuckingham.com/tags/containers/>containers</a></li><li><a href=https://ezrabuckingham.com/tags/devattackops/>devattackops</a></li><li><a href=https://ezrabuckingham.com/tags/gitlab/>gitlab</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share DevAttackOps: Container CI/CD Pipelines on twitter" href="https://twitter.com/intent/tweet/?text=DevAttackOps%3a%20Container%20CI%2fCD%20Pipelines&url=https%3a%2f%2fezrabuckingham.com%2fblog%2fcontainers-ci_cd%2f&hashtags=red-team%2cinfrastructure%2cdocker%2ccontainers%2cdevattackops%2cgitlab"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DevAttackOps: Container CI/CD Pipelines on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fezrabuckingham.com%2fblog%2fcontainers-ci_cd%2f&title=DevAttackOps%3a%20Container%20CI%2fCD%20Pipelines&summary=DevAttackOps%3a%20Container%20CI%2fCD%20Pipelines&source=https%3a%2f%2fezrabuckingham.com%2fblog%2fcontainers-ci_cd%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ezrabuckingham.com>Ezra Buckingham</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>