<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevAttackOps: Containerizing Red Team Infrastructure (Part 1) | Ezra Buckingham</title><meta name=keywords content="red-team,infrastructure,docker,containers,devattackops"><meta name=description content="Containerizing Attack and C2 infrastructure"><meta name=author content="Ezra Buckingham"><link rel=canonical href=https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ezra-buckingham.github.io/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://ezra-buckingham.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ezra-buckingham.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://ezra-buckingham.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ezra-buckingham.github.io/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="DevAttackOps: Containerizing Red Team Infrastructure (Part 1)"><meta property="og:description" content="Containerizing Attack and C2 infrastructure"><meta property="og:type" content="article"><meta property="og:url" content="https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/"><meta property="og:image" content="https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/blog-covers/containers.jpeg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-19T08:57:43-04:00"><meta property="article:modified_time" content="2022-08-19T08:57:43-04:00"><meta property="og:site_name" content="Ezra Buckingham"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/blog-covers/containers.jpeg"><meta name=twitter:title content="DevAttackOps: Containerizing Red Team Infrastructure (Part 1)"><meta name=twitter:description content="Containerizing Attack and C2 infrastructure"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://ezra-buckingham.github.io/blog/"},{"@type":"ListItem","position":3,"name":"DevAttackOps: Containerizing Red Team Infrastructure (Part 1)","item":"https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DevAttackOps: Containerizing Red Team Infrastructure (Part 1)","name":"DevAttackOps: Containerizing Red Team Infrastructure (Part 1)","description":"Containerizing Attack and C2 infrastructure","keywords":["red-team","infrastructure","docker","containers","devattackops"],"articleBody":"TLDR; Building containers for Red Team applications is easy, I have included a Cobalt Strike Dockerfile for you in the Artifacts section.\nSo here is my first actual blog post. In this series, I am going to talk about how Red Teams can use the same tools used by developers to both simplify Red Team infrastructure and generally make your life easier. I Part 1, I will be talking about why Red Teams should use containers in their workflows. As our European friends say, “Let’s get stuck in!”\nWhy Containerize? Here’s a question that I kept asking myself: what the hell is all the rage about containers? And honestly, it’s a great question! As a Red Teamer, here’s two big reasons why you should care (yes there are likely more, but these are the reasons from my perspective):\nRepeatability Red Teams are in the interesting category of teams since we are often deploying infrastructure into a variety of places. In doing so, we need to fight with various configurations that may be baked into each cloud provider’s OS images. This isn’t that big of a deal, but when you do run into one stupid configuration that is blocking your software from installing, it can be a huge time sink to try and determine what is going wrong. However, when you package all your code into a container, you know that no matter where you deploy that container to, it will always work the same way.\nEase of Use Have you ever had someone come up to you and complain that their install of insert-software-name isn’t working? Or have you ever onboarded a new team member and told them to just go play around with Cobalt Strike just to get familiar with Command and Control frameworks? I am willing to bet you have answered yes to one of these. If you have, then you can benefit from containers. When you build a container, instead of directing that person to the documentation or a Stack Overflow post of all the ways a Cobalt Strike install can fail, you could just containerize the solution and give that person the Dockerfile or a registry to pull from and they are all set.\nKey Terms So great, maybe I have convinced you about containerizing your Red Team tools! Before diving into “how” you do this, I need to define some key terms so I don’t lose you in the process:\nDockerfile: a text document that contains all the commands a user could call on the command line to assemble an image (From Docker official documentation here) Buildtime Arguments: dynamic arguments passed into Docker at container “build time” to allow for more control over a container image when building Runtime Arguments: arguments that are passed into the docker run command and then passed as arguments to the container execution point Building your First Container Wow, that was boring. Now for the fun stuff!\nLet’s work on building your first container. For example’s sake, let’s build a Cobalt Strike container. Before we begin, I will assume you have a very basic understanding of how Docker works. And also, since my team uses Debian-based operating systems, I will be making my example with debian:stable-slim as the base image.\nAutomating the Cobalt Strike Install Before we can build a container for Cobalt Strike, we need to automate the commands to install all the dependencies, download the Cobalt Strike package, extract the package, and run the update script (which will also license the product). Let’s break each step down…\nInstall All Dependencies Since Cobalt Strike is Java-based, we need to make sure that we have Java installed into the container. Additionally, there are other dependencies that we will want to install into the container to make sure everything works as intended. Since Debian uses apt, we can install the latest Java package and other packages from apt using the following command:\napt-get install --no-install-recommends -y ca-certificates curl expect git gnupg iproute2 openjdk-11-jdk wget Download the Cobalt Strike Package Great, now that we have all the required dependencies, we can download the package from their website. Should be a simple wget command, right? Well not exactly…\nTo download Cobalt Strike, go to https://download.cobaltstrike.com/download and enter your license key. You will be redirected to another page where you select your operating system and then download Cobalt Strike. This is a little challenging considering when you enter your license key, you get a “token” that is part of the download URL. In order to capture that token, you can make the initial GET request with your license key as a query parameter and use some Bash magic to extract that token. In this example, I have set the COBALTSTRIKE_LICENSE environment variable which allows me to dynamically reference it in the initial curl request.\nexport COBALTSTRIKE_LICENSE=\"","wordCount":"2690","inLanguage":"en","image":"https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/blog-covers/containers.jpeg","datePublished":"2022-08-19T08:57:43-04:00","dateModified":"2022-08-19T08:57:43-04:00","author":{"@type":"Person","name":"Ezra Buckingham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ezra-buckingham.github.io/blog/containerizing-red-team-infra/"},"publisher":{"@type":"Organization","name":"Ezra Buckingham","logo":{"@type":"ImageObject","url":"https://ezra-buckingham.github.io/favicon.png"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ezra-buckingham.github.io accesskey=h title="Ezra Buckingham (Alt + H)"><img src=https://ezra-buckingham.github.io/EzraBuckingham.png alt aria-label=logo height=35>Ezra Buckingham</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ezra-buckingham.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ezra-buckingham.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://ezra-buckingham.github.io/about-me/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>DevAttackOps: Containerizing Red Team Infrastructure (Part 1)</h1><div class=post-description>Containerizing Attack and C2 infrastructure</div><div class=post-meta><span title='2022-08-19 08:57:43 -0400 -0400'>August 19, 2022</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2690 words&nbsp;·&nbsp;Ezra Buckingham&nbsp;|&nbsp;<a href=https://github.com/ezra-buckingham/ezra-buckingham.github.io/blob/main/content/blog/containerizing-red-team-infra.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://ezra-buckingham.github.io/blog-covers/containers.jpeg alt=Containers></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-containerize aria-label="Why Containerize?">Why Containerize?</a><ul><li><a href=#repeatability aria-label=Repeatability>Repeatability</a></li><li><a href=#ease-of-use aria-label="Ease of Use">Ease of Use</a></li></ul></li><li><a href=#key-terms aria-label="Key Terms">Key Terms</a></li><li><a href=#building-your-first-container aria-label="Building your First Container">Building your First Container</a><ul><li><a href=#automating-the-cobalt-strike-install aria-label="Automating the Cobalt Strike Install">Automating the Cobalt Strike Install</a><ul><li><a href=#install-all-dependencies aria-label="Install All Dependencies">Install All Dependencies</a></li><li><a href=#download-the-cobalt-strike-package aria-label="Download the Cobalt Strike Package">Download the Cobalt Strike Package</a></li><li><a href=#extracting-and-updating-cobalt-strike aria-label="Extracting and Updating Cobalt Strike">Extracting and Updating Cobalt Strike</a></li></ul></li><li><a href=#creating-the-dockerfile aria-label="Creating the Dockerfile">Creating the Dockerfile</a><ul><li><a href=#using-buildtime-arguments aria-label="Using Buildtime Arguments">Using Buildtime Arguments</a></li><li><a href=#converting-the-manual-commands aria-label="Converting the Manual Commands">Converting the Manual Commands</a></li><li><a href=#exposing-ports aria-label="Exposing Ports">Exposing Ports</a></li><li><a href=#setting-the-entrypoint aria-label="Setting the Entrypoint">Setting the Entrypoint</a></li><li><a href=#putting-it-all-together aria-label="Putting it all Together">Putting it all Together</a></li><li><a href=#using-the-container-without-a-malleable-c2-profile aria-label="Using the Container (without a Malleable C2 Profile)">Using the Container (without a Malleable C2 Profile)</a></li><li><a href=#using-the-container-with-a-malleable-c2-profile aria-label="Using the Container (with a Malleable C2 Profile)">Using the Container (with a Malleable C2 Profile)</a></li></ul></li></ul></li><li><a href=#demonstration aria-label=Demonstration>Demonstration</a></li><li><a href=#whats-next aria-label="What&amp;rsquo;s Next?">What&rsquo;s Next?</a></li><li><a href=#artifacts aria-label=Artifacts>Artifacts</a></li></ul></div></details></div><div class=post-content><p><strong>TLDR;</strong> Building containers for Red Team applications is easy, I have included a Cobalt Strike Dockerfile for you in the <a href=#artifacts>Artifacts</a> section.</p><p>So here is my first actual blog post. In this series, I am going to talk about how Red Teams can use the same tools used by developers to both simplify Red Team infrastructure and generally make your life easier. I Part 1, I will be talking about why Red Teams <em>should</em> use containers in their workflows. As our European friends say, &ldquo;Let&rsquo;s get stuck in!&rdquo;</p><h1 id=why-containerize>Why Containerize?<a hidden class=anchor aria-hidden=true href=#why-containerize>#</a></h1><p>Here&rsquo;s a question that I kept asking myself: what the hell is all the rage about containers? And honestly, it&rsquo;s a great question! As a Red Teamer, here&rsquo;s two big reasons why you should care (yes there are likely more, but these are the reasons from my perspective):</p><h2 id=repeatability>Repeatability<a hidden class=anchor aria-hidden=true href=#repeatability>#</a></h2><p>Red Teams are in the interesting category of teams since we are often deploying infrastructure into a variety of places. In doing so, we need to fight with various configurations that may be baked into each cloud provider&rsquo;s OS images. This isn&rsquo;t that big of a deal, but when you do run into one stupid configuration that is blocking your software from installing, it can be a huge time sink to try and determine what is going wrong. However, when you package all your code into a container, you know that no matter where you deploy that container to, it will always work the same way.</p><h2 id=ease-of-use>Ease of Use<a hidden class=anchor aria-hidden=true href=#ease-of-use>#</a></h2><p>Have you ever had someone come up to you and complain that their install of <em>insert-software-name</em> isn&rsquo;t working? Or have you ever onboarded a new team member and told them to just go play around with Cobalt Strike just to get familiar with Command and Control frameworks? I am willing to bet you have answered yes to one of these. If you have, then you can benefit from containers. When you build a container, instead of directing that person to the documentation or a Stack Overflow post of all the ways a Cobalt Strike install can fail, you could just containerize the solution and give that person the <code>Dockerfile</code> or a registry to pull from and they are all set.</p><h1 id=key-terms>Key Terms<a hidden class=anchor aria-hidden=true href=#key-terms>#</a></h1><p>So great, maybe I have convinced you about containerizing your Red Team tools! Before diving into &ldquo;how&rdquo; you do this, I need to define some key terms so I don&rsquo;t lose you in the process:</p><ul><li>Dockerfile: a text document that contains all the commands a user could call on the command line to assemble an image (From Docker official documentation <a href=https://docs.docker.com/engine/reference/builder/>here</a>)</li><li>Buildtime Arguments: dynamic arguments passed into Docker at container &ldquo;build time&rdquo; to allow for more control over a container image when building</li><li>Runtime Arguments: arguments that are passed into the <code>docker run</code> command and then passed as arguments to the container execution point</li></ul><h1 id=building-your-first-container>Building your First Container<a hidden class=anchor aria-hidden=true href=#building-your-first-container>#</a></h1><p>Wow, that was boring. Now for the fun stuff!</p><p>Let&rsquo;s work on building your first container. For example&rsquo;s sake, let&rsquo;s build a Cobalt Strike container. Before we begin, I will assume you have a very basic understanding of how Docker works. And also, since my team uses Debian-based operating systems, I will be making my example with <code>debian:stable-slim</code> as the base image.</p><h2 id=automating-the-cobalt-strike-install>Automating the Cobalt Strike Install<a hidden class=anchor aria-hidden=true href=#automating-the-cobalt-strike-install>#</a></h2><p>Before we can build a container for Cobalt Strike, we need to automate the commands to install all the dependencies, download the Cobalt Strike package, extract the package, and run the update script (which will also license the product). Let&rsquo;s break each step down&mldr;</p><h3 id=install-all-dependencies>Install All Dependencies<a hidden class=anchor aria-hidden=true href=#install-all-dependencies>#</a></h3><p>Since Cobalt Strike is Java-based, we need to make sure that we have Java installed into the container. Additionally, there are other dependencies that we will want to install into the container to make sure everything works as intended. Since Debian uses <code>apt</code>, we can install the latest Java package and other packages from <code>apt</code> using the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>apt-get install --no-install-recommends -y ca-certificates curl expect git gnupg iproute2 openjdk-11-jdk wget
</span></span></code></pre></div><h3 id=download-the-cobalt-strike-package>Download the Cobalt Strike Package<a hidden class=anchor aria-hidden=true href=#download-the-cobalt-strike-package>#</a></h3><p>Great, now that we have all the required dependencies, we can download the package from their website. Should be a simple <code>wget</code> command, right? Well not exactly&mldr;</p><p>To download Cobalt Strike, go to <a href=https://download.cobaltstrike.com/download>https://download.cobaltstrike.com/download</a> and enter your license key. You will be redirected to another page where you select your operating system and then download Cobalt Strike. This is a little challenging considering when you enter your license key, you get a &ldquo;token&rdquo; that is part of the download URL. In order to capture that token, you can make the initial <code>GET</code> request with your license key as a query parameter and use some Bash magic to extract that token. In this example, I have set the <code>COBALTSTRIKE_LICENSE</code> environment variable which allows me to dynamically reference it in the initial curl request.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>COBALTSTRIKE_LICENSE</span><span class=o>=</span><span class=s2>&#34;&lt;cobaltstrike_license&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -s https://download.cobaltstrike.com/download -d <span class=s2>&#34;dlkey=</span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=p>|</span> grep <span class=s1>&#39;href=&#34;/downloads/&#39;</span> <span class=p>|</span> cut -d <span class=s1>&#39;/&#39;</span> -f3
</span></span></code></pre></div><p>From that curl command, we get the token that we need to include in the download URL. However, just getting the token does us no good. We need to save the token and use it in a subsequent request. We can do this by exporting the results of the <code>curl</code> command above to an environment variable by wrapping that command in <code>export TOKEN=$(&lt;curl-command>)</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>export</span> <span class=nv>TOKEN</span><span class=o>=</span><span class=k>$(</span>curl -s https://download.cobaltstrike.com/download -d <span class=s2>&#34;dlkey=</span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=p>|</span> grep <span class=s1>&#39;href=&#34;/downloads/&#39;</span> <span class=p>|</span> cut -d <span class=s1>&#39;/&#39;</span> -f3<span class=k>)</span>
</span></span></code></pre></div><p>Now that we have the token, all we need to do is make a <code>wget</code> to get the <code>cobaltstrike-dist.tgz</code> file and use Bash expansion to expand that token in the <code>wget</code> request.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>wget https://download.cobaltstrike.com/downloads/<span class=si>${</span><span class=nv>TOKEN</span><span class=si>}</span>/latest46/cobaltstrike-dist.tgz
</span></span></code></pre></div><h3 id=extracting-and-updating-cobalt-strike>Extracting and Updating Cobalt Strike<a hidden class=anchor aria-hidden=true href=#extracting-and-updating-cobalt-strike>#</a></h3><p>Now that we have the package, we can use <code>tar</code> to extract the package.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>tar zxf cobaltstrike-dist.tgz 
</span></span></code></pre></div><p>However, before we can run the <code>teamserver</code>, we need to run the <code>update</code> script to license the package we just downloaded. Since the <code>update</code> script will expect us to provide the license key via standard input, we can use an <code>echo</code> command to give it the key.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span> <span class=p>|</span> ./update
</span></span></code></pre></div><h2 id=creating-the-dockerfile>Creating the Dockerfile<a hidden class=anchor aria-hidden=true href=#creating-the-dockerfile>#</a></h2><p>Great, now we have a working version of Cobalt Strike installed! Next we want to take all of this and put it into a Dockerfile. Since a Dockerfile can just take and run bash commands to setup a container image, we can take everything we just learned and put it into a Dockerfile. To start building our first container, you will want to create a new directory and create a <code>Dockerfile</code> inside of the newly created directory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir cobaltstrike
</span></span><span class=line><span class=cl><span class=nb>cd</span> cobaltstrike
</span></span><span class=line><span class=cl>touch Dockerfile
</span></span></code></pre></div><h3 id=using-buildtime-arguments>Using Buildtime Arguments<a hidden class=anchor aria-hidden=true href=#using-buildtime-arguments>#</a></h3><p>Using our newly created directory and files, we now can start building out the Dockerfile. In the example above, I exported the <code>COBALTSTRIKE_LICENSE</code> as an environment variable. But how the hell can I mimic that functionality with Docker so I don&rsquo;t need to hardcode my license key into the Dockerfile? This is where buildtime argument come in. Using that buildtime argument, we will want to pass the Cobalt Strike license using the <code>build-arg</code> flag so that when we build the container, we have a fully licensed version of Cobalt Strike. The way we do this is by defining a <code>ARG</code> in the Dockerfile and then pass that <code>ARG</code> at build time.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:stable-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Required Arguments</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> COBALTSTRIKE_LICENSE<span class=err>
</span></span></span></code></pre></div><p>Now we can use that same environment variable called <code>COBALTSTRIKE_LICENSE</code> we set earlier to pass in the license key.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t cobaltstrike:latest --build-arg <span class=nv>COBALTSTRIKE_LICENSE</span><span class=o>=</span><span class=nv>$COBALTSTRIKE_LICENSE</span> .
</span></span></code></pre></div><h3 id=converting-the-manual-commands>Converting the Manual Commands<a hidden class=anchor aria-hidden=true href=#converting-the-manual-commands>#</a></h3><p>Now we need to convert all the manual commands we ran earlier into Dockerfile commands. Thankfully, we can use the <code>RUN</code> command in our Dockerfile to just copy and paste all the commands we ran earlier.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Install all dependencies</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	apt-get install --no-install-recommends -y ca-certificates curl expect git gnupg iproute2 openjdk-11-jdk wget <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	apt-get clean <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	update-java-alternatives -s java-1.11.0-openjdk-amd64<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install and update Cobalt Strike</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;COBALTSTRIKE_LICENSE: </span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=nb>export</span> <span class=nv>TOKEN</span><span class=o>=</span><span class=k>$(</span>curl -s https://download.cobaltstrike.com/download -d <span class=s2>&#34;dlkey=</span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=p>|</span> grep <span class=s1>&#39;href=&#34;/downloads/&#39;</span> <span class=p>|</span> cut -d <span class=s1>&#39;/&#39;</span> -f3<span class=k>)</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>cd</span> /opt <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	wget https://download.cobaltstrike.com/downloads/<span class=si>${</span><span class=nv>TOKEN</span><span class=si>}</span>/latest46/cobaltstrike-dist.tgz  <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	tar zxf cobaltstrike-dist.tgz <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	rm /etc/ssl/certs/java/cacerts <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	update-ca-certificates -f <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>cd</span> /opt/cobaltstrike <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>echo</span> <span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span> <span class=p>|</span> ./update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	mkdir /opt/cobaltstrike/mount<span class=err>
</span></span></span></code></pre></div><p><strong>Pro Tip:</strong> If you think you may have errors in your Dockerfile, just run the build command we defined earlier and it will tell you exactly where you have issues.</p><h3 id=exposing-ports>Exposing Ports<a hidden class=anchor aria-hidden=true href=#exposing-ports>#</a></h3><p>One of the most difficult concepts in Docker is networking. Because a container is an entire operating system <em>inside an operating system</em> the container has no knowledge of the base operating system&rsquo;s networking configuration (nor should it). Because of this, we want to tell the container <em>only what it needs to know</em> which is what ports it should expose to the host operating system.</p><p>For Cobalt Strike, the most used ports are the Teamserver connection port (50050/TCP) and the HTTPS C2 port (443/TCP). Because the container is a self-contained operating system (pardon my pun), we must use the <code>EXPOSE</code> function in our Dockerfile to tell the container to <em>explicitly allow</em> specific ports to be accessed. Doing this in a Dockerfile is easy.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>EXPOSE</span><span class=s> 50050 443 80 53/udp</span><span class=err>
</span></span></span></code></pre></div><p>By using the <code>EXPOSE</code> definition above, we are explicitly telling the container to allow networking communication to happen with 50050/TCP, 443/TCP, 80/TCP, and 53/UDP.</p><h3 id=setting-the-entrypoint>Setting the Entrypoint<a hidden class=anchor aria-hidden=true href=#setting-the-entrypoint>#</a></h3><p>The purpose of our container is to be a standalone implementation of the Cobalt Strike teamserver. Up to this point, we have Cobalt Strike being installed into the container and we have told the container what ports should be accessible, but we still haven&rsquo;t run the <code>teamserver</code> command to stand up the server. In Docker, we can use the <code>ENTRYPOINT</code> function to tell the container <em>what program to start when the container starts</em>. This means that when I run this container, I want to have it automatically run the <code>teamserver</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;./teamserver&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>In defining this <code>ENTRYPOINT</code>, the container will now boot and immediately execute that command. However, keep in mind that if that <code>teamserver</code> command exits / errors out, the container will stop. Whenever the <code>ENTRYPOINT</code> command exits, the entire container will stop. This is a typically a <em>gotcha</em> with most developers who start tinkering with containers.</p><p>Also, for those of you who have played with containers before, you probably know that there is also the <code>CMD</code> command that also exists. The key difference is that when you use <code>CMD</code> and pass in runtime arguments, you need to explicitly tell the container what base binary you want to run (essentially overwriting that <code>CMD</code> in the Dockerfile). If you want to learn more, here&rsquo;s a great <a href=https://awstip.com/docker-run-vs-cmd-vs-entrypoint-78ca2e5472bd>blog post</a> that covers the key differences.</p><h3 id=putting-it-all-together>Putting it all Together<a hidden class=anchor aria-hidden=true href=#putting-it-all-together>#</a></h3><p>Wow! You are still reading this? Kudos to you for being dedicated to wanting to learn! Now that we have everything we need to actually build the container, let&rsquo;s put it all together and build this damn thing! If we put all the commands above together, we get a Dockerfile that looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:stable-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Required Arguments</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> COBALTSTRIKE_LICENSE<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install all dependencies</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	apt-get install --no-install-recommends -y ca-certificates curl expect git gnupg iproute2 openjdk-11-jdk wget <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	apt-get clean <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	update-java-alternatives -s java-1.11.0-openjdk-amd64<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install and update Cobalt Strike</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;COBALTSTRIKE_LICENSE: </span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=nb>export</span> <span class=nv>TOKEN</span><span class=o>=</span><span class=k>$(</span>curl -s https://download.cobaltstrike.com/download -d <span class=s2>&#34;dlkey=</span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=p>|</span> grep <span class=s1>&#39;href=&#34;/downloads/&#39;</span> <span class=p>|</span> cut -d <span class=s1>&#39;/&#39;</span> -f3<span class=k>)</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>cd</span> /opt <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	wget https://download.cobaltstrike.com/downloads/<span class=si>${</span><span class=nv>TOKEN</span><span class=si>}</span>/latest46/cobaltstrike-dist.tgz  <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	tar zxf cobaltstrike-dist.tgz <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	rm /etc/ssl/certs/java/cacerts <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	update-ca-certificates -f <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>cd</span> /opt/cobaltstrike <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>echo</span> <span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span> <span class=p>|</span> ./update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	mkdir /opt/cobaltstrike/mount<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Expose the ports and run it</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /opt/cobaltstrike</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 50050 443 80 53/udp</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;./teamserver&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>And with that Dockerfile in our <code>cobaltstrike</code> directory, we can now build the container image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t cobaltstrike:latest --build-arg <span class=nv>COBALTSTRIKE_LICENSE</span><span class=o>=</span><span class=nv>$COBALTSTRIKE_LICENSE</span> .
</span></span></code></pre></div><h3 id=using-the-container-without-a-malleable-c2-profile>Using the Container (without a Malleable C2 Profile)<a hidden class=anchor aria-hidden=true href=#using-the-container-without-a-malleable-c2-profile>#</a></h3><p>We have a fancy schmancy new Cobalt Strike container, but now we want to <em>use</em> it. This is where we need to use the <code>docker run</code> command.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it cobaltstrike 192.168.1.1 password
</span></span></code></pre></div><p>With that command above, we are essentially running the following command <code>./teamserver 192.168.1.1 password</code>, but it is all in a container meaning that it is all running in it&rsquo;s own operating system (the <code>-it</code> flags are just sating to run the container in interactive mode so we can see the standard output of the container and when we use <code>CTRL + C</code> on that process, we kill the container).</p><p>However, if you remember what I said earlier, <em>the hardest part to Docker is networking</em> because although we are running the container, other computers have no idea that a container is running and listening on the ports we had <code>EXPOSE</code>&rsquo;d. To fix this, we need to define port proxies in our docker run command to tell the host operating system what ports it should listen to and what ports it should map to the container ports. This can be accomplished using the <code>-p &lt;host_port>:&lt;container_port></code> syntax.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it -p <span class=s2>&#34;50050:50050/tcp&#34;</span> -p <span class=s2>&#34;443:443/tcp&#34;</span> -p <span class=s2>&#34;80:80/tcp&#34;</span> -p <span class=s2>&#34;53:53/udp&#34;</span> cobaltstrike 192.168.1.1 password
</span></span></code></pre></div><p>From here, we now have a full Cobalt Strike container listening on all interfaces of your host operating system!</p><h3 id=using-the-container-with-a-malleable-c2-profile>Using the Container (with a Malleable C2 Profile)<a hidden class=anchor aria-hidden=true href=#using-the-container-with-a-malleable-c2-profile>#</a></h3><p>All of that was Super cool, right? But wait a minute&mldr; what the hell do I do if I want to use a Malleable C2 profile with the container? That is where bind mounts come into play. Also using docker, we can tell the container to mount to the host operating system to allow the container to access files on the host (keep in mind, doing so <em>has security implications</em> so make sure you understand those implications before doing this with all of your containers).</p><p>We can, inside the run command, create a bind mount using the <code>--mount</code> parameter. Let&rsquo;s say you already have a Malleable C2 profile created ant its called <code>c2.profile</code> and is already in your <code>cobaltstrike</code> directory you created earlier. In order to use that profile in the container, you can create a bind mound to that <code>cobaltstrike</code> directory in the container and then reference that profile (that now exists in the container&rsquo;s target directory) in the entrypoint.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span><span class=s2>&#34;</span>,target<span class=o>=</span>/opt/cobaltstrike/mount -p <span class=s2>&#34;50050:50050/tcp&#34;</span> -p <span class=s2>&#34;443:443/tcp&#34;</span> -p <span class=s2>&#34;80:80/tcp&#34;</span> -p <span class=s2>&#34;53:53/udp&#34;</span> cobaltstrike 192.168.1.1 password /opt/cobaltstrike/mount/c2.profile
</span></span></code></pre></div><p>With that, you have everything you now need to build and run your very own Cobalt Strike container.</p><h1 id=demonstration>Demonstration<a hidden class=anchor aria-hidden=true href=#demonstration>#</a></h1><p>After building the image, we can run the container with the bind mount.</p><p><img loading=lazy src=blog-images/container-run.png alt="Running the Cobalt Strike container"></p><p>And we see the container has booted properly, now we can use the host operating system&rsquo;s IP address to connect to the container.</p><p><img loading=lazy src=blog-images/connecting-to-cobaltstrike.png alt="Connecting to the Cobalt Strike container"></p><p>And if we hit connect, we become connected to our containerized version of Cobalt Strike!</p><p><img loading=lazy src=blog-images/connected-to-cobaltstrike.png alt="Connected to the Cobalt Strike container"></p><h1 id=whats-next>What&rsquo;s Next?<a hidden class=anchor aria-hidden=true href=#whats-next>#</a></h1><p>Next week, I will release a blog post on how we can now leverage a container registry to take this container image and allow other developers to use my prebuilt image and use one line of code to pull that container down and run it! Stay tuned!</p><h1 id=artifacts>Artifacts<a hidden class=anchor aria-hidden=true href=#artifacts>#</a></h1><p>The Dockerfile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:stable-slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Required Arguments</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> COBALTSTRIKE_LICENSE<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install all dependencies</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	apt-get install --no-install-recommends -y ca-certificates curl expect git gnupg iproute2 openjdk-11-jdk wget <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	apt-get clean <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	update-java-alternatives -s java-1.11.0-openjdk-amd64<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Install and update Cobalt Strike</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;COBALTSTRIKE_LICENSE: </span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=nb>export</span> <span class=nv>TOKEN</span><span class=o>=</span><span class=k>$(</span>curl -s https://download.cobaltstrike.com/download -d <span class=s2>&#34;dlkey=</span><span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span><span class=s2>&#34;</span> <span class=p>|</span> grep <span class=s1>&#39;href=&#34;/downloads/&#39;</span> <span class=p>|</span> cut -d <span class=s1>&#39;/&#39;</span> -f3<span class=k>)</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>cd</span> /opt <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	wget https://download.cobaltstrike.com/downloads/<span class=si>${</span><span class=nv>TOKEN</span><span class=si>}</span>/latest46/cobaltstrike-dist.tgz  <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	tar zxf cobaltstrike-dist.tgz <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	rm /etc/ssl/certs/java/cacerts <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	update-ca-certificates -f <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>cd</span> /opt/cobaltstrike <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	<span class=nb>echo</span> <span class=si>${</span><span class=nv>COBALTSTRIKE_LICENSE</span><span class=si>}</span> <span class=p>|</span> ./update <span class=o>&amp;&amp;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	mkdir /opt/cobaltstrike/mount<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Expose the ports and run it</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /opt/cobaltstrike</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 50050 443 80 53/udp</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> <span class=p>[</span><span class=s2>&#34;./teamserver&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></div><p>The build command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t cobaltstrike:latest --build-arg <span class=nv>COBALTSTRIKE_LICENSE</span><span class=o>=</span><span class=nv>$COBALTSTRIKE_LICENSE</span> .
</span></span></code></pre></div><p>The run command (without Malleable C2):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it -p <span class=s2>&#34;50050:50050/tcp&#34;</span> -p <span class=s2>&#34;443:443/tcp&#34;</span> -p <span class=s2>&#34;80:80/tcp&#34;</span> -p <span class=s2>&#34;53:53/udp&#34;</span> cobaltstrike 192.168.1.1 password
</span></span></code></pre></div><p>The run command (with Malleable C2):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span><span class=s2>&#34;</span>,target<span class=o>=</span>/opt/cobaltstrike/mount -p <span class=s2>&#34;50050:50050/tcp&#34;</span> -p <span class=s2>&#34;443:443/tcp&#34;</span> -p <span class=s2>&#34;80:80/tcp&#34;</span> -p <span class=s2>&#34;53:53/udp&#34;</span> cobaltstrike 192.168.1.1 password /opt/cobaltstrike/mount/c2.profile
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ezra-buckingham.github.io/tags/red-team/>red-team</a></li><li><a href=https://ezra-buckingham.github.io/tags/infrastructure/>infrastructure</a></li><li><a href=https://ezra-buckingham.github.io/tags/docker/>docker</a></li><li><a href=https://ezra-buckingham.github.io/tags/containers/>containers</a></li><li><a href=https://ezra-buckingham.github.io/tags/devattackops/>devattackops</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share DevAttackOps: Containerizing Red Team Infrastructure (Part 1) on twitter" href="https://twitter.com/intent/tweet/?text=DevAttackOps%3a%20Containerizing%20Red%20Team%20Infrastructure%20%28Part%201%29&url=https%3a%2f%2fezra-buckingham.github.io%2fblog%2fcontainerizing-red-team-infra%2f&hashtags=red-team%2cinfrastructure%2cdocker%2ccontainers%2cdevattackops"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DevAttackOps: Containerizing Red Team Infrastructure (Part 1) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fezra-buckingham.github.io%2fblog%2fcontainerizing-red-team-infra%2f&title=DevAttackOps%3a%20Containerizing%20Red%20Team%20Infrastructure%20%28Part%201%29&summary=DevAttackOps%3a%20Containerizing%20Red%20Team%20Infrastructure%20%28Part%201%29&source=https%3a%2f%2fezra-buckingham.github.io%2fblog%2fcontainerizing-red-team-infra%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ezra-buckingham.github.io>Ezra Buckingham</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>