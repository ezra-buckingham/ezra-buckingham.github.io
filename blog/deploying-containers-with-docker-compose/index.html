<!doctype html><html lang=en dir=auto><head><link rel=stylesheet type=text/css href=/css/override.css><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevAttackOps: Deploying Containers with Docker Compose (Part 3) | Ezra Buckingham</title><meta name=keywords content="red-team,infrastructure,docker,containers,devattackops,docker-compose"><meta name=description content="Deploy dynamic containers using Docker Compose"><meta name=author content="Ezra Buckingham"><link rel=canonical href=https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ezrabuckingham.com/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://ezrabuckingham.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ezrabuckingham.com/favicon-32x32.png><link rel=apple-touch-icon href=https://ezrabuckingham.com/apple-touch-icon.png><link rel=mask-icon href=https://ezrabuckingham.com/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W331QM25YY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W331QM25YY",{anonymize_ip:!1})}</script><meta property="og:title" content="DevAttackOps: Deploying Containers with Docker Compose (Part 3)"><meta property="og:description" content="Deploy dynamic containers using Docker Compose"><meta property="og:type" content="article"><meta property="og:url" content="https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/"><meta property="og:image" content="https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/blog-covers/docker-compose-deploy-ansible.jpeg"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-10-16T16:14:53-04:00"><meta property="article:modified_time" content="2022-10-16T16:14:53-04:00"><meta property="og:site_name" content="Ezra Buckingham"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/blog-covers/docker-compose-deploy-ansible.jpeg"><meta name=twitter:title content="DevAttackOps: Deploying Containers with Docker Compose (Part 3)"><meta name=twitter:description content="Deploy dynamic containers using Docker Compose"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://ezrabuckingham.com/blog/"},{"@type":"ListItem","position":3,"name":"DevAttackOps: Deploying Containers with Docker Compose (Part 3)","item":"https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"DevAttackOps: Deploying Containers with Docker Compose (Part 3)","name":"DevAttackOps: Deploying Containers with Docker Compose (Part 3)","description":"Deploy dynamic containers using Docker Compose","keywords":["red-team","infrastructure","docker","containers","devattackops","docker-compose"],"articleBody":"TLDR; Now that we have a container image registry, we can leverage the power of Docker Compose to deploy “containers as a configuration” to hosts. Check out the Artifacts section to see some examples.\nDisclaimer: If you have not read DevAttackOps Part 1 or Part 2, you should start there. We will be building off the concepts of those posts in this post.\nWelcome to part 3 of the DevAttackOps series where I talk about all things regarding Red Team infrastructure automation! If you have stuck around this long, thank you! Let’s start with some basics and the problem we are trying to address.\nMulti-Container Problems We now have an understanding of the value-add we get from containers for Red Team infrastructure. However, let’s revisit the docker run command we use to start a container. To start Cobalt Strike, we would use something like the following:\ndocker run -it --mount type=bind,source=\"$(pwd)\",target=/opt/cobaltstrike/mount -p \"50050:50050/tcp\" -p \"443:443/tcp\" -p \"80:80/tcp\" -p \"53:53/udp\" cobaltstrike 192.168.1.1 password /opt/cobaltstrike/mount/c2.profile When we investigate this docker run command, we can see a lot of complex syntax. Let’s remember, I am an idiot and remembering that command syntax is unrealistic for my tiny brain. I often have to go back to DevAttackOps Part 1 to remember what command I need to use to start Cobalt Strike with all the proper port mappings and bind mounts for Cobalt Strike to operate as I need.\nOh and what if I also wanted to use Sliver on that exact same server? Well now I need to go look up the command I use for Sliver too. Luckily, I am super organized with all my code and it takes me no time at all to find that command (please read with heavy sarcasm). To start Sliver, we would use something like the following:\ndocker run -it --name sliver -p \"3333:3333/tcp\" -p \"3443:443/tcp\" -p \"380:80/tcp\" -p \"353:53/udp\" sliver -p 3333 Also, take note of the port mappings I use for Sliver as I am using 2 different command and control frameworks on the same host. Because of this, I now need to change some of the port mappings so that I don’t have port collisions on the host operating system (since both Cobalt Strike and Sliver both have some of the same protocols implemented for C2).\nThis got me thinking… Wouldn’t it be nice if I could instead of having to remember a complex command and syntax like the two above, and use a single configuration file to define all those options? Yes it would be! And lucky for me, others before me thought of the exact same thing and came up with a solution called “Docker Compose.”\nWhat is Docker Compose? On the official Docker website, they define Docker Compose as the following:\na tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. (https://docs.docker.com/compose/)\nThis means now I can take the commands above, convert them into a docker-compose.yml file (which is the standard name for a Docker Compose file), use some automation to deploy that docker-compose.yml to a host, and then use the following command to start all the containers (no matter their configuration):\ndocker-compose up -d This is so much easier to remember than the two docker run commands I have listed above. But now, we need to figure out how to convert the two commands above into Docker Compose syntax.\nNote: You will need to install Docker Compose as it will often not come pre-installed with Docker. Follow the directions to install it by following the official Docker instructions here. Also, some versions of Docker compose use the docker compose syntax while others use the docker-compose syntax. They both operate in the same way, the only difference is the hyphen :)\nCompose Syntax If we look at the Docker Compose getting started page, there are a few examples that we can glean some information from.\nversion: \"3.9\" services: web: build: . ports: - \"8000:5000\" redis: image: \"redis:alpine\" In this example, we are telling Docker to bring up two different containers, one called web and another called redis. In the web container, we are building the container image on the fly using a Dockerfile that is located in the current directory and then mapping the web container TCP port 5000 to the host operating system’s TCP port 8000. With the redis container, we are just pulling an image back from the official Docker registry (this is assumed as there is no full path to a container registry / image).\nThis seems simple enough. It’s just a YAML file that defines two containers where one gets built on the fly and the other gets pulled from an external registry. Let’s take this example and adapt it to work for just Sliver first.\nConverting Docker Run to Docker Compose In DevAttackOps Part 2 we built out a CI/CD pipeline to automatically build out our container images and publish them to a private registry. Today, we are going to stick with pulling those images from our private registry instead of building the images on the fly like the web container does in the example above. So first, let’s start with Sliver.\nSliver Conversion To start converting Sliver, we first need to create a docker-compose.yml file.\ntouch docker-compose.yml Then, we need to create a key called sliver under the services key inside of our newly created docker-compose.yml file and tell sliver to pull the container image from our private registry we built in Part 2. And just for added ease of use, we will add a container_name to sliver called sliver just to make it easier to label / reference containers once they are running.\nversion: \"3.9\" services: sliver: container_name: sliver image: registry.gitlab.com/ezragit/container-ci_cd/sliver:latest All we are doing is telling Docker Compose to pull back the image from our private container registry and once the container is started, name it sliver. If we now save our new docker-compose.yml on a host with Docker and Docker Compose already installed and then run docker-compose up -d in the same directory as the docker-compose.yml file, Docker will pull back that image and run it in detached mode (hence the -d).\nRemember: You may need to authenticate to your private container registry before running docker-compose up -d (more information exists in Part 2)\nRunning docker-compose up -d with the sliver container as defined above works just fine, but Sliver requires that you provide runtime arguments to the container to tell it to run in daemon mode and what port to expose for multiplayer mode. Since Docker Compose exposes the runtime arguments as a configuration option, we can easily add our custom runtime arguments using the command key inside of the docker-compose.yml file.\nversion: \"3.9\" services: sliver: container_name: sliver image: registry.gitlab.com/ezragit/container-ci_cd/sliver:latest command: \"daemon -p 3333\" Sweet, now the only thing we still need to do is map the ports. Using the same syntax as the web container above, we can create a ports list and convert the docker run port mappings to a YAML list.\nversion: \"3.9\" services: sliver: container_name: sliver image: registry.gitlab.com/ezragit/container-ci_cd/sliver:latest command: \"daemon -p 3333\" ports: - \"3333:3333/tcp\" - \"3443:443/tcp\" - \"380:80/tcp\" - \"353:53/udp\" Since some of the Sliver ports are TCP and some are UDP, I find it is generally a better practice to be explicit in telling Docker what protocol each port will use, but keep in mind that it will default to TCP. But now that we have our Docker Compose definition for Sliver, we can try it out!\nStarting Sliver Now, in the same directory as our new docker-compose.yml file, we can use the docker-compose up -d command to start Sliver in detached mode.\nWe can confirm that the container is up by running docker container ls.\nAnd then if we want to stop the container, we can run docker-compose down.\nSweet, it works! Wow, I never thought that would actually work.\nCobalt Strike Conversion We have Sliver converted, but what if we wanted to convert Cobalt Strike too. For sanity’s sake, let’s start with a fresh docker-compose.yml file to make sure we are isolating any errors to be Cobalt Strike specific.\necho \"\" \u003e docker-compose.yml Now that we have a fresh compose file, we will want to follow all the same steps as above, but with the Cobalt Strike docker run command. Doing so will give us the following docker-compose.yml.\nversion: \"3.9\" services: cobaltstrike: container_name: cobaltstrike image: registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest command: \"192.168.1.1 password /opt/cobaltstrike/mount/c2.profile\" ports: - \"1111:50050/tcp\" - \"1443:443/tcp\" - \"180:80/tcp\" - \"153:53/udp\" If we save the docker-compose.yml with that content and then use docker-compose up -d, we will see the Cobalt Strike container start for about 5 seconds and then exit. This is because we haven’t defined the bind mount that will give the container access to the /opt/cobaltstrike/mount/c2.profile file. We can fix this by adding a volumes key inside of cobaltstrike and defining a list item that defines the path to mount inside the container.\nversion: \"3.9\" services: cobaltstrike: container_name: cobaltstrike image: registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest command: \"192.168.1.1 password /opt/cobaltstrike/mount/c2.profile\" ports: - \"1111:50050/tcp\" - \"1443:443/tcp\" - \"180:80/tcp\" - \"153:53/udp\" volumes: - type: bind source: /opt/container/cobaltstrike/mount target: /opt/cobaltstrike/mount Before we start the container again, we need to make sure the /opt/container/cobaltstrike/mount/c2.profile file and path exist.\nmkdir -p /opt/container/cobaltstrike/mount \u0026\u0026 vi /opt/container/cobaltstrike/mount/c2.profile And then just for example’s sake, you can paste the following into c2.profile.\nset sample_name \"Docker Compose\"; http-get { set uri \"/itstheredteam\"; client { metadata { netbiosu; parameter \"tmp\"; } } server { header \"Content-Type\" \"application/octet-stream\"; output { print; } } } http-post { set uri \"/isittheredteam\"; client { header \"Content-Type\" \"application/octet-stream\"; id { uri-append; } output { print; } } server { header \"Content-Type\" \"text/html\"; output { print; } } } Now, we can run the docker-compose up -d command and Cobalt Strike should run with the exact same configuration as our docker run command.\nCombining the Container Compose Definitions We now have two working Docker Compose definitions for our Sliver and Cobalt Strike containers. Now let’s combine them! Going back to the example provided from the Docker Compose documentation, we can just combine both the sliver and cobaltstrike container definitions under the services key and that’s it!\nversion: \"3.9\" services: sliver: container_name: sliver image: registry.gitlab.com/ezragit/container-ci_cd/sliver:latest command: \"daemon -p 3333\" ports: - \"3333:3333/tcp\" - \"3443:443/tcp\" - \"380:80/tcp\" - \"353:53/udp\" cobaltstrike: container_name: cobaltstrike image: registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest command: \"192.168.1.1 password /opt/cobaltstrike/mount/c2.profile\" ports: - \"1111:50050/tcp\" - \"1443:443/tcp\" - \"180:80/tcp\" - \"153:53/udp\" volumes: - type: bind source: /opt/container/cobaltstrike/mount target: /opt/cobaltstrike/mount Now, in the same directory as our new docker-compose.yml file, we can use the docker-compose up -d command to start both Sliver and Cobalt Strike in detached mode.\nWe can confirm that the containers are up by running docker container ls.\nAnd then if we want to stop both containers, we can run docker-compose down.\nAnd boom, that’s it. Now we can easily take this docker-compose.yml file to any server and use the exact same syntax to start all of our containers!\nArtifacts services: cobaltstrike: container_name: cobaltstrike image: command: \"192.168.1.1 password /opt/cobaltstrike/mount/c2.profile\" ports: - \"1111:50050/tcp\" - \"1443:443/tcp\" - \"180:80/tcp\" - \"153:53/udp\" volumes: - type: bind source: /opt/container/cobaltstrike/mount target: /opt/cobaltstrike/mount sliver: container_name: sliver image: command: \"daemon -p 3333\" ports: - \"3333:3333/tcp\" - \"3443:443/tcp\" - \"380:80/tcp\" - \"353:53/udp\" volumes: - type: bind source: /opt/container/sliver/mount target: /opt/sliver/mount ","wordCount":"1890","inLanguage":"en","image":"https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/blog-covers/docker-compose-deploy-ansible.jpeg","datePublished":"2022-10-16T16:14:53-04:00","dateModified":"2022-10-16T16:14:53-04:00","author":{"@type":"Person","name":"Ezra Buckingham"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ezrabuckingham.com/blog/deploying-containers-with-docker-compose/"},"publisher":{"@type":"Organization","name":"Ezra Buckingham","logo":{"@type":"ImageObject","url":"https://ezrabuckingham.com/favicon.png"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ezrabuckingham.com accesskey=h title="Ezra Buckingham (Alt + H)"><img src=https://ezrabuckingham.com/EzraBuckingham.png alt aria-label=logo height=35>Ezra Buckingham</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://ezrabuckingham.com/blog/ title="Blog Posts"><span>blog</span></a></li><li><a href=https://ezrabuckingham.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://ezrabuckingham.com/about-me/ title="about me"><span>about me</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>DevAttackOps: Deploying Containers with Docker Compose (Part 3)</h1><div class=post-description>Deploy dynamic containers using Docker Compose</div><div class=post-meta><span title='2022-10-16 16:14:53 -0400 -0400'>October 16, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1890 words&nbsp;·&nbsp;Ezra Buckingham&nbsp;|&nbsp;<a href=https://github.com/ezra-buckingham/ezra-buckingham.github.io/blob/main/content/blog/deploying-containers-with-docker-compose.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://ezrabuckingham.com/blog-covers/docker-compose-deploy-ansible.jpeg alt="Gears and chains"></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#multi-container-problems aria-label="Multi-Container Problems">Multi-Container Problems</a></li><li><a href=#what-is-docker-compose aria-label="What is Docker Compose?">What is Docker Compose?</a><ul><li><a href=#compose-syntax aria-label="Compose Syntax">Compose Syntax</a></li></ul></li><li><a href=#converting-docker-run-to-docker-compose aria-label="Converting Docker Run to Docker Compose">Converting Docker Run to Docker Compose</a><ul><li><a href=#sliver-conversion aria-label="Sliver Conversion">Sliver Conversion</a><ul><li><a href=#starting-sliver aria-label="Starting Sliver">Starting Sliver</a></li></ul></li><li><a href=#cobalt-strike-conversion aria-label="Cobalt Strike Conversion">Cobalt Strike Conversion</a></li><li><a href=#combining-the-container-compose-definitions aria-label="Combining the Container Compose Definitions">Combining the Container Compose Definitions</a></li></ul></li><li><a href=#artifacts aria-label=Artifacts>Artifacts</a></li></ul></div></details></div><div class=post-content><p><strong>TLDR;</strong> Now that we have a container image registry, we can leverage the power of Docker Compose to deploy &ldquo;containers as a configuration&rdquo; to hosts. Check out the <a href=#artifacts>Artifacts</a> section to see some examples.</p><p><strong>Disclaimer:</strong> If you have not read DevAttackOps Part 1 or Part 2, you should start there. We will be building off the concepts of those posts in this post.</p><p>Welcome to part 3 of the DevAttackOps series where I talk about all things regarding Red Team infrastructure automation! If you have stuck around this long, thank you! Let&rsquo;s start with some basics and the problem we are trying to address.</p><h1 id=multi-container-problems>Multi-Container Problems<a hidden class=anchor aria-hidden=true href=#multi-container-problems>#</a></h1><p>We now have an understanding of the value-add we get from containers for Red Team infrastructure. However, let&rsquo;s revisit the <code>docker run</code> command we use to start a container. To start Cobalt Strike, we would use something like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span><span class=s2>&#34;</span><span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span><span class=s2>&#34;</span>,target<span class=o>=</span>/opt/cobaltstrike/mount -p <span class=s2>&#34;50050:50050/tcp&#34;</span> -p <span class=s2>&#34;443:443/tcp&#34;</span> -p <span class=s2>&#34;80:80/tcp&#34;</span> -p <span class=s2>&#34;53:53/udp&#34;</span> cobaltstrike 192.168.1.1 password /opt/cobaltstrike/mount/c2.profile
</span></span></code></pre></div><p>When we investigate this <code>docker run</code> command, we can see a lot of complex syntax. Let&rsquo;s remember, I am an idiot and remembering that command syntax is unrealistic for my tiny brain. I often have to go back to <a href=../containerizing-red-team-infra>DevAttackOps Part 1</a> to remember what command I need to use to start Cobalt Strike with all the proper port mappings and bind mounts for Cobalt Strike to operate as I need.</p><p>Oh and what if I <em>also</em> wanted to use Sliver on that exact same server? Well now I need to go look up the command I use for Sliver too. Luckily, I am super organized with all my code and it takes me no time at all to find that command (please read with heavy sarcasm). To start Sliver, we would use something like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -it --name sliver -p <span class=s2>&#34;3333:3333/tcp&#34;</span> -p <span class=s2>&#34;3443:443/tcp&#34;</span> -p <span class=s2>&#34;380:80/tcp&#34;</span> -p <span class=s2>&#34;353:53/udp&#34;</span> sliver -p <span class=m>3333</span>
</span></span></code></pre></div><p>Also, take note of the port mappings I use for Sliver as I am using 2 different command and control frameworks on the same host. Because of this, I now need to change some of the port mappings so that I don&rsquo;t have port collisions on the host operating system (since both Cobalt Strike and Sliver both have some of the same protocols implemented for C2).</p><p>This got me thinking&mldr; Wouldn&rsquo;t it be nice if I could instead of having to remember a complex command and syntax like the two above, and use a single configuration file to define all those options? Yes it would be! And lucky for me, others before me thought of the exact same thing and came up with a solution called &ldquo;Docker Compose.&rdquo;</p><h1 id=what-is-docker-compose>What is Docker Compose?<a hidden class=anchor aria-hidden=true href=#what-is-docker-compose>#</a></h1><p>On the official Docker website, they define Docker Compose as the following:</p><blockquote><p>a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. (<a href=https://docs.docker.com/compose/>https://docs.docker.com/compose/</a>)</p></blockquote><p>This means now I can take the commands above, convert them into a <code>docker-compose.yml</code> file (which is the standard name for a Docker Compose file), use some automation to deploy that <code>docker-compose.yml</code> to a host, and then use the following command to start all the containers (no matter their configuration):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose up -d
</span></span></code></pre></div><p>This is so much easier to remember than the two <code>docker run</code> commands I have listed above. But now, we need to figure out how to convert the two commands above into Docker Compose syntax.</p><p><strong>Note:</strong> You will need to install Docker Compose as it will often not come pre-installed with Docker. Follow the directions to install it by following the <a href=https://docs.docker.com/compose/install/>official Docker instructions here</a>. Also, some versions of Docker compose use the <code>docker compose</code> syntax while others use the <code>docker-compose</code> syntax. They both operate in the same way, the only difference is the hyphen :)</p><h2 id=compose-syntax>Compose Syntax<a hidden class=anchor aria-hidden=true href=#compose-syntax>#</a></h2><p>If we look at the Docker Compose <a href=https://docs.docker.com/compose/gettingstarted/#step-3-define-services-in-a-compose-file>getting started</a> page, there are a few examples that we can glean some information from.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;8000:5000&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>redis</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;redis:alpine&#34;</span><span class=w>
</span></span></span></code></pre></div><p>In this example, we are telling Docker to bring up two different containers, one called <code>web</code> and another called <code>redis</code>. In the <code>web</code> container, we are building the container image on the fly using a <code>Dockerfile</code> that is located in the current directory and then mapping the <code>web</code> container TCP port 5000 to the host operating system&rsquo;s TCP port 8000. With the <code>redis</code> container, we are just pulling an image back from the official Docker registry (this is assumed as there is no full path to a container registry / image).</p><p>This seems simple enough. It&rsquo;s just a YAML file that defines two containers where one gets built on the fly and the other gets pulled from an external registry. Let&rsquo;s take this example and adapt it to work for just Sliver first.</p><h1 id=converting-docker-run-to-docker-compose>Converting Docker Run to Docker Compose<a hidden class=anchor aria-hidden=true href=#converting-docker-run-to-docker-compose>#</a></h1><p>In <a href=../containers-ci_cd>DevAttackOps Part 2</a> we built out a CI/CD pipeline to automatically build out our container images and publish them to a private registry. Today, we are going to stick with pulling those images from our private registry instead of building the images on the fly like the <code>web</code> container does in the example above. So first, let&rsquo;s start with Sliver.</p><h2 id=sliver-conversion>Sliver Conversion<a hidden class=anchor aria-hidden=true href=#sliver-conversion>#</a></h2><p>To start converting Sliver, we first need to create a <code>docker-compose.yml</code> file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>touch docker-compose.yml
</span></span></code></pre></div><p>Then, we need to create a key called <code>sliver</code> under the <code>services</code> key inside of our newly created <code>docker-compose.yml</code> file and tell <code>sliver</code> to pull the container <code>image</code> from our private registry we built in <a href=../containers-ci_cd>Part 2</a>. And just for added ease of use, we will add a <code>container_name</code> to <code>sliver</code> called <code>sliver</code> just to make it easier to label / reference containers once they are running.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/sliver:latest</span><span class=w>
</span></span></span></code></pre></div><p>All we are doing is telling Docker Compose to pull back the image from our private container registry and once the container is started, name it <code>sliver</code>. If we now save our new <code>docker-compose.yml</code> on a host with Docker and Docker Compose already installed and then run <code>docker-compose up -d</code> in the same directory as the <code>docker-compose.yml</code> file, Docker will pull back that image and run it in detached mode (hence the <code>-d</code>).</p><p><strong>Remember:</strong> You may need to authenticate to your private container registry before running <code>docker-compose up -d</code> (more information exists in <a href=../containers-ci_cd/#understanding-the-container-registry>Part 2</a>)</p><p>Running <code>docker-compose up -d</code> with the <code>sliver</code> container as defined above works just fine, but Sliver requires that you provide runtime arguments to the container to tell it to run in daemon mode and what port to expose for multiplayer mode. Since Docker Compose exposes the runtime arguments as a configuration option, we can easily add our custom runtime arguments using the <code>command</code> key inside of the <code>docker-compose.yml</code> file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/sliver:latest </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;daemon -p 3333&#34;</span><span class=w>
</span></span></span></code></pre></div><p>Sweet, now the only thing we still need to do is map the ports. Using the same syntax as the <code>web</code> container above, we can create a <code>ports</code> list and convert the <code>docker run</code> port mappings to a YAML list.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/sliver:latest </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;daemon -p 3333&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;3333:3333/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;3443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;380:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;353:53/udp&#34;</span><span class=w>
</span></span></span></code></pre></div><p>Since some of the Sliver ports are TCP and some are UDP, I find it is generally a better practice to be explicit in telling Docker what protocol each port will use, but keep in mind that it will default to TCP. But now that we have our Docker Compose definition for Sliver, we can try it out!</p><h3 id=starting-sliver>Starting Sliver<a hidden class=anchor aria-hidden=true href=#starting-sliver>#</a></h3><p>Now, in the same directory as our new <code>docker-compose.yml</code> file, we can use the <code>docker-compose up -d</code> command to start Sliver in detached mode.</p><figure class=align-center><img loading=lazy src=../../blog-images/start-sliver-docker-compose.png#center width=450 height=auto></figure><p>We can confirm that the container is up by running <code>docker container ls</code>.</p><figure class=align-center><img loading=lazy src=../../blog-images/show-running-sliver.png#center></figure><p>And then if we want to stop the container, we can run <code>docker-compose down</code>.</p><figure class=align-center><img loading=lazy src=../../blog-images/stop-sliver-docker-compose.png#center width=350 height=auto></figure><p>Sweet, it works! Wow, I never thought that would actually work.</p><h2 id=cobalt-strike-conversion>Cobalt Strike Conversion<a hidden class=anchor aria-hidden=true href=#cobalt-strike-conversion>#</a></h2><p>We have Sliver converted, but what if we wanted to convert Cobalt Strike too. For sanity&rsquo;s sake, let&rsquo;s start with a fresh <code>docker-compose.yml</code> file to make sure we are isolating any errors to be Cobalt Strike specific.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;&#34;</span> &gt; docker-compose.yml
</span></span></code></pre></div><p>Now that we have a fresh compose file, we will want to follow all the same steps as above, but with the Cobalt Strike <code>docker run</code> command. Doing so will give us the following <code>docker-compose.yml</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>cobaltstrike</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;192.168.1.1 password /opt/cobaltstrike/mount/c2.profile&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1111:50050/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;180:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;153:53/udp&#34;</span><span class=w>
</span></span></span></code></pre></div><p>If we save the <code>docker-compose.yml</code> with that content and then use <code>docker-compose up -d</code>, we will see the Cobalt Strike container start for about 5 seconds and then exit. This is because we haven&rsquo;t defined the bind mount that will give the container access to the <code>/opt/cobaltstrike/mount/c2.profile</code> file. We can fix this by adding a <code>volumes</code> key inside of <code>cobaltstrike</code> and defining a list item that defines the path to mount inside the container.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>cobaltstrike</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;192.168.1.1 password /opt/cobaltstrike/mount/c2.profile&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1111:50050/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;180:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;153:53/udp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>bind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>source</span><span class=p>:</span><span class=w> </span><span class=l>/opt/container/cobaltstrike/mount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w> </span><span class=l>/opt/cobaltstrike/mount</span><span class=w>
</span></span></span></code></pre></div><p>Before we start the container again, we need to make sure the <code>/opt/container/cobaltstrike/mount/c2.profile</code> file and path exist.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir -p /opt/container/cobaltstrike/mount <span class=o>&amp;&amp;</span> vi /opt/container/cobaltstrike/mount/c2.profile
</span></span></code></pre></div><p>And then just for example&rsquo;s sake, you can paste the following into <code>c2.profile</code>.</p><pre tabindex=0><code>set sample_name &#34;Docker Compose&#34;;

http-get {
  set uri &#34;/itstheredteam&#34;;
  client {
    metadata {
      netbiosu;
      parameter &#34;tmp&#34;;
    }
  }
  server {
    header &#34;Content-Type&#34; &#34;application/octet-stream&#34;;
    output {
      print;
    }
  }
}

http-post {
  set uri &#34;/isittheredteam&#34;;
  client {
    header &#34;Content-Type&#34; &#34;application/octet-stream&#34;;
    id {
      uri-append;
    }
    output {
      print;
    }
  }
  server {
    header &#34;Content-Type&#34; &#34;text/html&#34;;
    output {
      print;
    }
  }
}
</code></pre><p>Now, we can run the <code>docker-compose up -d</code> command and Cobalt Strike should run with the exact same configuration as our <code>docker run</code> command.</p><h2 id=combining-the-container-compose-definitions>Combining the Container Compose Definitions<a hidden class=anchor aria-hidden=true href=#combining-the-container-compose-definitions>#</a></h2><p>We now have two working Docker Compose definitions for our Sliver and Cobalt Strike containers. Now let&rsquo;s combine them! Going back to the example provided from the Docker Compose documentation, we can just combine both the <code>sliver</code> and <code>cobaltstrike</code> container definitions under the <code>services</code> key and that&rsquo;s it!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;3.9&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/sliver:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;daemon -p 3333&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;3333:3333/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;3443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;380:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;353:53/udp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>cobaltstrike</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.gitlab.com/ezragit/container-ci_cd/cobaltstrike:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;192.168.1.1 password /opt/cobaltstrike/mount/c2.profile&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1111:50050/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;180:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;153:53/udp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>bind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>source</span><span class=p>:</span><span class=w> </span><span class=l>/opt/container/cobaltstrike/mount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w> </span><span class=l>/opt/cobaltstrike/mount</span><span class=w>
</span></span></span></code></pre></div><p>Now, in the same directory as our new <code>docker-compose.yml</code> file, we can use the <code>docker-compose up -d</code> command to start both Sliver and Cobalt Strike in detached mode.</p><figure class=align-center><img loading=lazy src=../../blog-images/start-cs-sliver-docker-compose.png#center width=450 height=auto></figure><p>We can confirm that the containers are up by running <code>docker container ls</code>.</p><figure class=align-center><img loading=lazy src=../../blog-images/show-running-cs-sliver.png#center></figure><p>And then if we want to stop both containers, we can run <code>docker-compose down</code>.</p><figure class=align-center><img loading=lazy src=../../blog-images/stop-cs-sliver-docker-compose.png#center width=450 height=auto></figure><p>And boom, that&rsquo;s it. Now we can easily take this <code>docker-compose.yml</code> file to any server and use the exact same syntax to start all of our containers!</p><h1 id=artifacts>Artifacts<a hidden class=anchor aria-hidden=true href=#artifacts>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>cobaltstrike</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>cobaltstrike</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image_path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;192.168.1.1 password /opt/cobaltstrike/mount/c2.profile&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1111:50050/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;1443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;180:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;153:53/udp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>bind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>source</span><span class=p>:</span><span class=w> </span><span class=l>/opt/container/cobaltstrike/mount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w> </span><span class=l>/opt/cobaltstrike/mount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>sliver</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>container_name</span><span class=p>:</span><span class=w> </span><span class=l>sliver</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;image_path&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;daemon -p 3333&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;3333:3333/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;3443:443/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;380:80/tcp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;353:53/udp&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>bind</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>source</span><span class=p>:</span><span class=w> </span><span class=l>/opt/container/sliver/mount</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>target</span><span class=p>:</span><span class=w> </span><span class=l>/opt/sliver/mount</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://ezrabuckingham.com/tags/red-team/>red-team</a></li><li><a href=https://ezrabuckingham.com/tags/infrastructure/>infrastructure</a></li><li><a href=https://ezrabuckingham.com/tags/docker/>docker</a></li><li><a href=https://ezrabuckingham.com/tags/containers/>containers</a></li><li><a href=https://ezrabuckingham.com/tags/devattackops/>devattackops</a></li><li><a href=https://ezrabuckingham.com/tags/docker-compose/>docker-compose</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share DevAttackOps: Deploying Containers with Docker Compose (Part 3) on twitter" href="https://twitter.com/intent/tweet/?text=DevAttackOps%3a%20Deploying%20Containers%20with%20Docker%20Compose%20%28Part%203%29&url=https%3a%2f%2fezrabuckingham.com%2fblog%2fdeploying-containers-with-docker-compose%2f&hashtags=red-team%2cinfrastructure%2cdocker%2ccontainers%2cdevattackops%2cdocker-compose"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share DevAttackOps: Deploying Containers with Docker Compose (Part 3) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fezrabuckingham.com%2fblog%2fdeploying-containers-with-docker-compose%2f&title=DevAttackOps%3a%20Deploying%20Containers%20with%20Docker%20Compose%20%28Part%203%29&summary=DevAttackOps%3a%20Deploying%20Containers%20with%20Docker%20Compose%20%28Part%203%29&source=https%3a%2f%2fezrabuckingham.com%2fblog%2fdeploying-containers-with-docker-compose%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://ezra-buckingham.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2022 <a href=https://ezrabuckingham.com>Ezra Buckingham</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>